#!/bin/bash

function print_help_and_exit
{
cat >&2 << 'EOF'

'ftdmp-all' docks, scores and ranks complex structures of proteins or nucleic acids

Options:
    --job-name                string  *  job name
    --pre-docked-input-dir    string     pre-docked input directory path 
    --static-file             string     hetero docking static input file path
    --static-sel              string     hetero docking query to restrict static atoms, default is '[]'
    --static-chain            string     hetero docking chain name or chain renaming rule to apply for static atoms, default is ''
    --static-rotation-seed    number     random seed to initially rotate static part, default is 1
    --mobile-file             string     hetero or homo docking mobile input file path
    --mobile-sel              string     hetero or homo docking query to restrict mobile atoms, default is '[]'
    --mobile-chain            string     hetero or homo docking chain name or chain renaming rule to apply for mobile atoms, default is ''
    --mobile-rotation-seed    number     random seed to initially rotate mobile part, default is 2
    --symmetry-docking        string     homo docking symmetry to apply for the mobile input file, default is ''
    --subselect-contacts      string     query to subselect inter-chain contacts for scoring, default is '[]'
    --constraints-required    string     query to check required inter-chain contacts, default is ''
    --constraints-banned      string     query to check banned inter-chain contacts, default is ''
    --constraint-clashes      number     max allowed clash score, default is ''
    --reference               string     input structure file to compute CAD-score with, default is ''
    --openmm-forcefield       string     forcefield name for OpenMM-based operations, default is ''
    --ftdmp-root              string     ftdmp root path, default is '' (autodetected from the calling command)
    --conda-path              string     conda installation path, default is ''
    --conda-early             string     flag to activate conda as early as possible
    --conda-env               string     conda main environment name, default is ''
    --conda-env-for-gnn       string     conda GNN environment name, equals the main environment name if not set
    --sam-parameters          string     additional SAM parameters, default is '-top=8000 -show=2000 -clusters=2000'
    --use-ftdock              string     flag to use ftdock, default is 'true'
    --use-hex                 string     flag to use HEX, default is 'false'
    --ftdock-keep             number     ftdock keep parameter, default is 1
    --ftdock-angle-step       number     ftdock angle step parameter, default is 9
    --ftdock-min-grid-sep     number     minimum grid separation between same-rotation translations, default is 20
    --hex-macro-mode          string     flag to enable HEX macro mode, default is 'true'
    --hex-max-solutions       number     max number of docking solutions for HEX, default is 10000
    --hex-script              string     semicolon-sparated additional commands for HEX, default is ''
    --hex-swap-and-repeat     string     flag to run HEX twice with monomers swapped, default is 'false'
    --parallel-docking        number     number of processes to run when docking, default is 8
    --parallel-scoring        number     number of processes to run when scoring, default is 8
    --cache-dir               string     cache directory path to store results of past slower calculations
    --sbatch-for-ftdock       string     sbatch parameters to run docking with ftdock in parallel, default is ''
    --sbatch-for-hex-or-sam   string     sbatch parameters to run docking with HEX or SAM on cluster, default is ''
    --sbatch-scoring          string     sbatch parameters to run scoring in parallel, default is ''
    --score-symmetry          string     flag to score symmetry, default is 'false'
    --local-columns           string     flag to add per-residue scores to the global output table, default is 'false'
    --remap-cadscore          string     flag to use optimal chains remapping for CAD-score, default is 'false'
    --scoring-full-top        number     number of top complexes to keep after full scoring stage, default is 1000
    --scoring-full-top-slow   number     number of top complexes to keep before slow full scoring stage, default is 9999999
    --scoring-rank-names      string  *  rank names to use, or name of a standard set of rank names
    --scoring-ranks-top       number     number of top complexes to consider for each ranking, default is 100
    --scoring-jury-slices     string     slice sizes sequence definition for ranks jury scoring, default is '5 20'
    --scoring-jury-cluster    number     clustering threshold for ranks jury scoring, default is 0.9
    --scoring-jury-maxs       number     number of max values to use for ranks jury scoring, default is 1
    --redundancy-threshold    number     minimal ordered redundancy value to accept, default is 0.9
    --build-complexes         number     number of top complexes to build, default is 0
    --multiply-chains         string     options to multiply chains, default is ''
    --relax-complexes         string     options to relax complexes, default is ''
    --only-dock-and-score     string     flag to only dock, score and quit after scoring, default is 'false'
    --diversify               number     step of CAD-score to diversify scoring results and exit, default is ''
    --plot-jury-scores        string     flag to output plot of jury scores, default is 'false'
    --casp15-qa               string     flag to output CASP15 QA answer, default is 'false'
    --casp15-qa-target        string     target name for outputting CASP15 QA answer, default is '_THETARGET_'
    --casp15-qa-author-id     string     author ID for outputting CASP15 QA answer, default is '_THEAUTHOR_'
    --output-dir              string  *  output directory path
    --help | -h                          flag to display help message and exit

Examples:

    ftdmp-all --job-name 'j1' --static-file './chainA.pdb' --mobile-file './chainB.pdb' \
      --scoring-rank-names 'standard_for_protein_protein' --output-dir './results'

    ftdmp-all --job-name 'j2' --pre-docked-input-dir './predocked' \
      --scoring-rank-names 'standard_for_protein_protein' --output-dir './results'

EOF
exit 1
}

################################################################################

if [ -z "$1" ]
then
	print_help_and_exit
fi

echo >&2 "ftdpm-all: reading and checking options"

JOB_NAME=""
PRE_DOCKED_INPUT_DIR=""
STATIC_STRUCTURE_FILE=""
STATIC_STRUCTURE_SELECTION="[]"
STATIC_STRUCTURE_CHAIN=""
STATIC_STRUCTURE_ROTATION_SEED="1"
MOBILE_STRUCTURE_FILE=""
MOBILE_STRUCTURE_SELECTION="[]"
MOBILE_STRUCTURE_CHAIN=""
MOBILE_STRUCTURE_ROTATION_SEED="2"
SYMMETRY_DOCKING=""
INTERFACE_SUBSELECTION="[]"
CONSTRAINTS_REQUIRED=""
CONSTRAINTS_BANNED=""
CONSTRAINT_CLASHES=""
REFERENCE_STRUCTURE_FILE_FOR_COMPARISON=""
OPENMM_FORCEFIELD=""
FTDMP_ROOT=""
CONDA_PATH=""
CONDA_EARLY="false"
CONDA_ENV=""
CONDA_ENV_FOR_GNN=""
SAM_PARAMETERS="-top=8000 -show=2000 -clusters=2000"
USE_FTDOCK="true"
USE_HEX="false"
FTDOCK_KEEP="1"
FTDOCK_ANGLE_STEP="9"
FTDOCK_MIN_GRID_SEP="20"
HEX_MACRO_MODE="true"
HEX_MAX_SOLUTIONS="10000"
HEX_SCRIPT=""
HEX_SWAP_AND_REPEAT="false"
DOCKING_PROCESSORS="8"
SCORING_PROCESSORS="8"
CACHE_DIR=""
DOCKING_SBATCH_FOR_FTDOCK=""
DOCKING_SBATCH_FOR_HEX_OR_SAM=""
SCORING_SBATCH=""
SCORE_SYMMETRY="false"
LOCAL_COLUMNS="false"
REMAP_CADSCORE="false"
SCORING_TOP_STAGE1="1000"
SCORING_TOP_STAGE1_FOR_SLOW="9999999"
SCORING_RANKS=""
SCORING_TOP_STAGE2="100"
SCORING_RANKS_JURY_SLICES="5 20" 
SCORING_RANKS_JURY_CLUSTER="0.9" 
SCORING_RANKS_JURY_MAX_VALUES="1" 
NUMBER_OF_COMPLEXES_TO_BUILD="0"
REDUNDANCY_THRESHOLD="0.9"
MULTIPLY_CHAINS=""
RELAX_COMPLEXES=""
ONLY_DOCK_AND_SCORE="false"
DIVERSIFY=""
PLOT_JURY_SCORES="false"
CASP15QA="false"
CASP15QA_TARGET="_THETARGET_"
CASP15QA_AUTHOR="_THEAUTHOR_"
OUTPUT_PATH=""
HELP_MODE="false"

while [[ $# > 0 ]]
do
	OPTION="$1"
	OPTARG="$2"
	shift
	case $OPTION in
	--job-name)
		JOB_NAME="$OPTARG"
		shift
		;;
	--pre-docked-input-dir)
		PRE_DOCKED_INPUT_DIR="$OPTARG"
		shift
		;;
	--static-file)
		STATIC_STRUCTURE_FILE="$OPTARG"
		shift
		;;
	--static-sel)
		STATIC_STRUCTURE_SELECTION="$OPTARG"
		shift
		;;
	--static-chain)
		STATIC_STRUCTURE_CHAIN="$OPTARG"
		shift
		;;
	--static-rotation-seed)
		STATIC_STRUCTURE_ROTATION_SEED="$OPTARG"
		shift
		;;
	--mobile-file)
		MOBILE_STRUCTURE_FILE="$OPTARG"
		shift
		;;
	--mobile-sel)
		MOBILE_STRUCTURE_SELECTION="$OPTARG"
		shift
		;;
	--mobile-chain)
		MOBILE_STRUCTURE_CHAIN="$OPTARG"
		shift
		;;
	--mobile-rotation-seed)
		MOBILE_STRUCTURE_ROTATION_SEED="$OPTARG"
		shift
		;;
	--symmetry-docking)
		SYMMETRY_DOCKING="$OPTARG"
		shift
		;;
	--subselect-contacts)
		INTERFACE_SUBSELECTION="$OPTARG"
		shift
		;;
	--constraints-required)
		CONSTRAINTS_REQUIRED="$OPTARG"
		shift
		;;
	--constraints-banned)
		CONSTRAINTS_BANNED="$OPTARG"
		shift
		;;
	--constraint-clashes)
		CONSTRAINT_CLASHES="$OPTARG"
		shift
		;;
	--reference)
		REFERENCE_STRUCTURE_FILE_FOR_COMPARISON="$OPTARG"
		shift
		;;
	--openmm-forcefield)
		OPENMM_FORCEFIELD="$OPTARG"
		shift
		;;
	--ftdmp-root)
		FTDMP_ROOT="$OPTARG"
		shift
		;;
	--conda-path)
		CONDA_PATH="$OPTARG"
		shift
		;;
	--conda-early)
		CONDA_EARLY="$OPTARG"
		shift
		;;
	--conda-env)
		CONDA_ENV="$OPTARG"
		CONDA_ENV_FOR_GNN="$OPTARG"
		shift
		;;
	--conda-env-for-gnn)
		CONDA_ENV_FOR_GNN="$OPTARG"
		shift
		;;
	--sam-parameters)
		SAM_PARAMETERS="$OPTARG"
		shift
		;;
	--use-ftdock)
		USE_FTDOCK="$OPTARG"
		shift
		;;
	--use-hex)
		USE_HEX="$OPTARG"
		shift
		;;
	--ftdock-keep)
		FTDOCK_KEEP="$OPTARG"
		shift
		;;
	--ftdock-angle-step)
		FTDOCK_ANGLE_STEP="$OPTARG"
		shift
		;;
	--ftdock-min-grid-sep)
		FTDOCK_MIN_GRID_SEP="$OPTARG"
		shift
		;;
	--hex-macro-mode)
		HEX_MACRO_MODE="$OPTARG"
		shift
		;;
	--hex-max-solutions)
		HEX_MAX_SOLUTIONS="$OPTARG"
		shift
		;;
	--hex-script)
		HEX_SCRIPT="$OPTARG"
		shift
		;;
	--hex-swap-and-repeat)
		HEX_SWAP_AND_REPEAT="$OPTARG"
		shift
		;;
	--parallel-docking)
		DOCKING_PROCESSORS="$OPTARG"
		shift
		;;
	--parallel-scoring)
		SCORING_PROCESSORS="$OPTARG"
		shift
		;;
	--cache-dir)
		CACHE_DIR="$OPTARG"
		shift
		;;
	--sbatch-for-ftdock)
		DOCKING_SBATCH_FOR_FTDOCK="$OPTARG"
		shift
		;;
	--sbatch-for-hex-or-sam)
		DOCKING_SBATCH_FOR_HEX_OR_SAM="$OPTARG"
		shift
		;;
	--sbatch-scoring)
		SCORING_SBATCH="$OPTARG"
		shift
		;;
	--score-symmetry)
		SCORE_SYMMETRY="$OPTARG"
		shift
		;;
	--local-columns)
		LOCAL_COLUMNS="$OPTARG"
		shift
		;;
	--remap-cadscore)
		REMAP_CADSCORE="$OPTARG"
		shift
		;;
	--scoring-full-top)
		SCORING_TOP_STAGE1="$OPTARG"
		shift
		;;
	--scoring-full-top-slow)
		SCORING_TOP_STAGE1_FOR_SLOW="$OPTARG"
		shift
		;;
	--scoring-rank-names)
		SCORING_RANKS="$OPTARG"
		shift
		;;
	--scoring-ranks-top)
		SCORING_TOP_STAGE2="$OPTARG"
		shift
		;;
	--scoring-jury-slices)
		SCORING_RANKS_JURY_SLICES="$OPTARG"
		shift
		;;
	--scoring-jury-cluster)
		SCORING_RANKS_JURY_CLUSTER="$OPTARG"
		shift
		;;
	--scoring-jury-maxs)
		SCORING_RANKS_JURY_MAX_VALUES="$OPTARG"
		shift
		;;
	--build-complexes)
		NUMBER_OF_COMPLEXES_TO_BUILD="$OPTARG"
		shift
		;;
	--redundancy-threshold)
		REDUNDANCY_THRESHOLD="$OPTARG"
		shift
		;;
	--multiply-chains)
		MULTIPLY_CHAINS="$OPTARG"
		shift
		;;
	--relax-complexes)
		RELAX_COMPLEXES="$OPTARG"
		shift
		;;
	--only-dock-and-score)
		ONLY_DOCK_AND_SCORE="$OPTARG"
		shift
		;;
	--diversify)
		DIVERSIFY="$OPTARG"
		shift
		;;
	--plot-jury-scores )
		PLOT_JURY_SCORES="$OPTARG"
		shift
		;;
	--casp15-qa)
		CASP15QA="$OPTARG"
		shift
		;;
	--casp15-qa-target)
		CASP15QA_TARGET="$OPTARG"
		shift
		;;
	--casp15-qa-author-id)
		CASP15QA_AUTHOR="$OPTARG"
		shift
		;;
	--output-dir)
		OUTPUT_PATH="$OPTARG"
		shift
		;;
	-h|--help)
		HELP_MODE="true"
		;;
	*)
		echo >&2 "Error: invalid command line option '$OPTION'"
		exit 1
		;;
	esac
done

if [ "$HELP_MODE" == "true" ]
then
	print_help_and_exit
fi

[ -n "$JOB_NAME" ] || { echo >&2 "Error: job name not provided"; exit 1;}

DOCKING_REGIME=""

if [ -n "$PRE_DOCKED_INPUT_DIR" ]
then
	[ -d "$PRE_DOCKED_INPUT_DIR" ] || { echo >&2 "Error: invalid pre-docked files input directory '$PRE_DOCKED_INPUT_DIR'"; exit 1;}
	[ "$(find $PRE_DOCKED_INPUT_DIR -type f -not -empty | wc -l)" -gt "1" ] || { echo >&2 "Error: pre-docked files input directory '$PRE_DOCKED_INPUT_DIR' does not contain more than 1 file"; exit 1;}
	
	[ -z "$SYMMETRY_DOCKING" ] || { echo >&2 "Error: docking symmetry provided in pre-docked mode"; exit 1;}
	
	[ -z "$STATIC_STRUCTURE_FILE" ] || { echo >&2 "Error: static structure file provided in pre-docked mode"; exit 1;}
	
	[ -z "$MOBILE_STRUCTURE_FILE" ] || { echo >&2 "Error: mobile structure file not provided in pre-docked mode"; exit 1;}
	
	DOCKING_REGIME="pre-docked"
else
	if [ -n "$SYMMETRY_DOCKING" ]
	then
		[ -z "$STATIC_STRUCTURE_FILE" ] || { echo >&2 "Error: static structure file provided in homo docking mode"; exit 1;}
		
		[ -n "$MOBILE_STRUCTURE_FILE" ] || { echo >&2 "Error: mobile structure file not provided in homo docking mode"; exit 1;}
		[ -s "$MOBILE_STRUCTURE_FILE" ] || { echo >&2 "Error: mobile structure file non-existing or empty in homo docking mode"; exit 1;}
		[ -n "$MOBILE_STRUCTURE_SELECTION" ] || { echo >&2 "Error: mobile structure selection not defined in homo docking mode"; exit 1;}
		
		DOCKING_REGIME="homo"
	else
		[ -n "$STATIC_STRUCTURE_FILE" ] || { echo >&2 "Error: static structure file not provided in hetero docking mode"; exit 1;}
		[ -s "$STATIC_STRUCTURE_FILE" ] || { echo >&2 "Error: static structure file non-existing or empty in hetero docking mode"; exit 1;}
		[ -n "$STATIC_STRUCTURE_SELECTION" ] || { echo >&2 "Error: static structure selection not defined in hetero docking mode"; exit 1;}
		
		[ -n "$MOBILE_STRUCTURE_FILE" ] || { echo >&2 "Error: mobile structure file not provided in hetero docking mode"; exit 1;}
		[ -s "$MOBILE_STRUCTURE_FILE" ] || { echo >&2 "Error: mobile structure file non-existing or empty in hetero docking mode"; exit 1;}
		[ -n "$MOBILE_STRUCTURE_SELECTION" ] || { echo >&2 "Error: mobile structure selection not defined in hetero docking mode"; exit 1;}
		
		DOCKING_REGIME="hetero"
	fi
fi

[ -n "$INTERFACE_SUBSELECTION" ] || { echo >&2 "Error: contacts subselection not defined"; exit 1; }

[ -n "$SCORING_RANKS" ] || { echo >&2 "Error: scoring rank names not provided"; exit 1;}

[ -n "$SCORING_RANKS_JURY_SLICES" ] || { echo >&2 "Error: scoring ranks jury slices not defined"; exit 1;}

[ -n "$OUTPUT_PATH" ] || { echo >&2 "Error: output path not provided"; exit 1;}

################################################################################

if [ "$SCORING_RANKS" == "simple_for_protein_protein" ]
then
	SCORING_RANKS="
raw_FIV_iface_energy_rank
raw_FIV_energy_clash_tour_rank
"
fi

if [ "$SCORING_RANKS" == "standard_for_protein_protein" ]
then
	SCORING_RANKS="
raw_FIV_iface_energy_rank
raw_FIV_energy_clash_tour_rank
raw_FIVb_iface_energy_rank
raw_FIVb_energy_clash_tour_rank
raw_FIV_sr_iface_energy_rank
raw_FIV_sr_energy_clash_tour_rank
raw_FIVb_sr_iface_energy_rank
raw_FIVb_sr_energy_clash_tour_rank
"
fi

if [ "$SCORING_RANKS" == "standard_for_protein_protein_no_sr" ]
then
	SCORING_RANKS="
raw_FIV_iface_energy_rank
raw_FIV_energy_clash_tour_rank
raw_FIVb_iface_energy_rank
raw_FIVb_energy_clash_tour_rank
"
fi

if [ "$SCORING_RANKS" == "standard_for_protein_protein_only_sr" ]
then
	SCORING_RANKS="
raw_FIV_sr_iface_energy_rank
raw_FIV_sr_energy_clash_tour_rank
raw_FIVb_sr_iface_energy_rank
raw_FIVb_sr_energy_clash_tour_rank
"
fi

if [ "$SCORING_RANKS" == "standard_for_generic" ]
then
	SCORING_RANKS="
raw_FIVb_iface_energy_rank
raw_FIVb_energy_clash_tour_rank
"
fi

if [ "$SCORING_RANKS" == "extended_for_protein_protein" ]
then
	SCORING_RANKS="
raw_FIV_iface_energy_rank
raw_FIV_energy_clash_tour_rank
raw_FIVb_iface_energy_rank
raw_FIVb_energy_clash_tour_rank
raw_FIGNN_sum_of_gnn_scores_rank
raw_FIGNN_average_gnn_score_rank
raw_FIGNN_gnn_scores_tour_rank
raw_FIGNN_average_pcadscore_rank
raw_FIGNN_weighted_average_pcadscore_rank
raw_FIGNN_sum_of_gnn_scores_clash_tour_rank
raw_FIGNN_sum_of_gnn_scores_FIV_energy_tour_rank
raw_FIGNN_avg_gnn_score_FIV_energy_tour_rank
raw_FIGNN_wavg_pcadscore_FIV_energy_tour_rank
raw_FIGNN_sum_of_gnn_scores_FIVb_energy_tour_rank
raw_FIGNN_avg_gnn_score_FIVb_energy_tour_rank
raw_FIGNN_wavg_pcadscore_FIVb_energy_tour_rank
raw_FIV_and_FGV_light_tour_rank
raw_FIV_and_FGV_dark_tour_rank
raw_FIGNN_and_FGV_light_tour_rank
raw_FIGNN_and_FGV_dark_tour_rank
raw_FIV_sr_iface_energy_rank
raw_FIV_sr_energy_clash_tour_rank
raw_FIVb_sr_iface_energy_rank
raw_FIVb_sr_energy_clash_tour_rank
raw_FIGNN_sr_sum_of_gnn_scores_rank
raw_FIGNN_sr_average_gnn_score_rank
raw_FIGNN_sr_gnn_scores_tour_rank
raw_FIGNN_sr_average_pcadscore_rank
raw_FIGNN_sr_weighted_average_pcadscore_rank
raw_FIGNN_sr_sum_of_gnn_scores_clash_tour_rank
raw_FIGNN_sr_sum_of_gnn_scores_FIV_sr_energy_tour_rank
raw_FIGNN_sr_avg_gnn_score_FIV_sr_energy_tour_rank
raw_FIGNN_sr_wavg_pcadscore_FIV_sr_energy_tour_rank
raw_FIGNN_sr_sum_of_gnn_scores_FIVb_sr_energy_tour_rank
raw_FIGNN_sr_avg_gnn_score_FIVb_sr_energy_tour_rank
raw_FIGNN_sr_wavg_pcadscore_FIVb_sr_energy_tour_rank
"
fi

if [ "$SCORING_RANKS" == "extended_for_protein_protein_no_glob" ]
then
	SCORING_RANKS="
raw_FIV_iface_energy_rank
raw_FIV_energy_clash_tour_rank
raw_FIVb_iface_energy_rank
raw_FIVb_energy_clash_tour_rank
raw_FIGNN_sum_of_gnn_scores_rank
raw_FIGNN_average_gnn_score_rank
raw_FIGNN_gnn_scores_tour_rank
raw_FIGNN_average_pcadscore_rank
raw_FIGNN_weighted_average_pcadscore_rank
raw_FIGNN_sum_of_gnn_scores_clash_tour_rank
raw_FIGNN_sum_of_gnn_scores_FIV_energy_tour_rank
raw_FIGNN_avg_gnn_score_FIV_energy_tour_rank
raw_FIGNN_wavg_pcadscore_FIV_energy_tour_rank
raw_FIGNN_sum_of_gnn_scores_FIVb_energy_tour_rank
raw_FIGNN_avg_gnn_score_FIVb_energy_tour_rank
raw_FIGNN_wavg_pcadscore_FIVb_energy_tour_rank
raw_FIV_sr_iface_energy_rank
raw_FIV_sr_energy_clash_tour_rank
raw_FIVb_sr_iface_energy_rank
raw_FIVb_sr_energy_clash_tour_rank
raw_FIGNN_sr_sum_of_gnn_scores_rank
raw_FIGNN_sr_average_gnn_score_rank
raw_FIGNN_sr_gnn_scores_tour_rank
raw_FIGNN_sr_average_pcadscore_rank
raw_FIGNN_sr_weighted_average_pcadscore_rank
raw_FIGNN_sr_sum_of_gnn_scores_clash_tour_rank
raw_FIGNN_sr_sum_of_gnn_scores_FIV_sr_energy_tour_rank
raw_FIGNN_sr_avg_gnn_score_FIV_sr_energy_tour_rank
raw_FIGNN_sr_wavg_pcadscore_FIV_sr_energy_tour_rank
raw_FIGNN_sr_sum_of_gnn_scores_FIVb_sr_energy_tour_rank
raw_FIGNN_sr_avg_gnn_score_FIVb_sr_energy_tour_rank
raw_FIGNN_sr_wavg_pcadscore_FIVb_sr_energy_tour_rank
"
fi

if [ "$SCORING_RANKS" == "extended_for_protein_protein_no_sr" ]
then
	SCORING_RANKS="
raw_FIV_iface_energy_rank
raw_FIV_energy_clash_tour_rank
raw_FIVb_iface_energy_rank
raw_FIVb_energy_clash_tour_rank
raw_FIGNN_sum_of_gnn_scores_rank
raw_FIGNN_average_gnn_score_rank
raw_FIGNN_gnn_scores_tour_rank
raw_FIGNN_average_pcadscore_rank
raw_FIGNN_weighted_average_pcadscore_rank
raw_FIGNN_sum_of_gnn_scores_clash_tour_rank
raw_FIGNN_sum_of_gnn_scores_FIV_energy_tour_rank
raw_FIGNN_avg_gnn_score_FIV_energy_tour_rank
raw_FIGNN_wavg_pcadscore_FIV_energy_tour_rank
raw_FIGNN_sum_of_gnn_scores_FIVb_energy_tour_rank
raw_FIGNN_avg_gnn_score_FIVb_energy_tour_rank
raw_FIGNN_wavg_pcadscore_FIVb_energy_tour_rank
raw_FIV_and_FGV_light_tour_rank
raw_FIV_and_FGV_dark_tour_rank
raw_FIGNN_and_FGV_light_tour_rank
raw_FIGNN_and_FGV_dark_tour_rank
"
fi

if [ "$SCORING_RANKS" == "extended_for_protein_protein_no_glob_no_sr" ]
then
	SCORING_RANKS="
raw_FIV_iface_energy_rank
raw_FIV_energy_clash_tour_rank
raw_FIVb_iface_energy_rank
raw_FIVb_energy_clash_tour_rank
raw_FIGNN_sum_of_gnn_scores_rank
raw_FIGNN_average_gnn_score_rank
raw_FIGNN_gnn_scores_tour_rank
raw_FIGNN_average_pcadscore_rank
raw_FIGNN_weighted_average_pcadscore_rank
raw_FIGNN_sum_of_gnn_scores_clash_tour_rank
raw_FIGNN_sum_of_gnn_scores_FIV_energy_tour_rank
raw_FIGNN_avg_gnn_score_FIV_energy_tour_rank
raw_FIGNN_wavg_pcadscore_FIV_energy_tour_rank
raw_FIGNN_sum_of_gnn_scores_FIVb_energy_tour_rank
raw_FIGNN_avg_gnn_score_FIVb_energy_tour_rank
raw_FIGNN_wavg_pcadscore_FIVb_energy_tour_rank
"
fi

if [ "$SCORING_RANKS" == "extended_for_protein_protein_only_sr" ]
then
	SCORING_RANKS="
raw_FIV_sr_iface_energy_rank
raw_FIV_sr_energy_clash_tour_rank
raw_FIVb_sr_iface_energy_rank
raw_FIVb_sr_energy_clash_tour_rank
raw_FIGNN_sr_sum_of_gnn_scores_rank
raw_FIGNN_sr_average_gnn_score_rank
raw_FIGNN_sr_gnn_scores_tour_rank
raw_FIGNN_sr_average_pcadscore_rank
raw_FIGNN_sr_weighted_average_pcadscore_rank
raw_FIGNN_sr_sum_of_gnn_scores_clash_tour_rank
raw_FIGNN_sr_sum_of_gnn_scores_FIV_sr_energy_tour_rank
raw_FIGNN_sr_avg_gnn_score_FIV_sr_energy_tour_rank
raw_FIGNN_sr_wavg_pcadscore_FIV_sr_energy_tour_rank
raw_FIGNN_sr_sum_of_gnn_scores_FIVb_sr_energy_tour_rank
raw_FIGNN_sr_avg_gnn_score_FIVb_sr_energy_tour_rank
raw_FIGNN_sr_wavg_pcadscore_FIVb_sr_energy_tour_rank
"
fi

SCORING_RANKS="$(echo ${SCORING_RANKS} | tr '\n' ' ' | sed 's/\s\+/ /g' | sed 's/^\s\+//' | sed 's/\s\+$//')"

SCORING_MODE_PROTEIN="false"
SCORING_MODE_PROTEIN_SIDECHAIN_REBUILT="false"
SCORING_MODE_GENERIC="false"
SCORING_MODE_GENERIC_SIDECHAIN_REBUILT="false"
SCORING_MODE_PROTEIN_GNN="false"
SCORING_MODE_PROTEIN_GNN_SIDECHAIN_REBUILT="false"
SCORING_MODE_PROTEIN_GLOBAL="false"

if [[ "$SCORING_RANKS" == *"_FIV_"* ]]
then
	SCORING_MODE_PROTEIN="true"
fi

if [[ "$SCORING_RANKS" == *"_FIV_sr_"* ]]
then
	SCORING_MODE_PROTEIN_SIDECHAIN_REBUILT="true"
fi

if [[ "$SCORING_RANKS" == *"_FIVb_"* ]]
then
	SCORING_MODE_GENERIC="true"
fi

if [[ "$SCORING_RANKS" == *"_FIVb_sr_"* ]]
then
	SCORING_MODE_GENERIC_SIDECHAIN_REBUILT="true"
fi

if [[ "$SCORING_RANKS" == *"_FIGNN_"* ]]
then
	SCORING_MODE_PROTEIN_GNN="true"
fi

if [[ "$SCORING_RANKS" == *"_FIGNN_sr_"* ]]
then
	SCORING_MODE_PROTEIN_GNN_SIDECHAIN_REBUILT="true"
fi

if [[ "$SCORING_RANKS" == *"_FGV_"* ]]
then
	SCORING_MODE_PROTEIN_GLOBAL="true"
fi

if [ -z "$REFERENCE_STRUCTURE_FILE_FOR_COMPARISON" ] && [ "$SCORING_MODE_PROTEIN" != "true" ] && [ "$SCORING_MODE_PROTEIN_SIDECHAIN_REBUILT" != "true" ] && [ "$SCORING_MODE_GENERIC" != "true" ] && [ "$SCORING_MODE_GENERIC_SIDECHAIN_REBUILT" != "true" ] && [ "$SCORING_MODE_PROTEIN_GNN" != "true" ] && [ "$SCORING_MODE_PROTEIN_GNN_SIDECHAIN_REBUILT" != "true" ] && [ "$SCORING_MODE_PROTEIN_GLOBAL" != "true" ]
then
	echo >&2 "Error: no scoring action enabled"
	exit 1
fi

################################################################################

if [ "$CONDA_EARLY" == "true" ]
then
	if [ -z "$CONDA_DEFAULT_ENV" ]
	then
		if [ -z "$CONDA_PATH" ]
		then
			echo >&2 "Error: not in conda environment, and the conda path is not provided"
			exit 1
		fi
		if [ ! -s "${CONDA_PATH}/bin/activate" ]
		then
			echo >&2 "Error: no conda activation script '${CONDA_PATH}/bin/activate'"
			exit 1
		fi
		source "${CONDA_PATH}/bin/activate"
	fi
	
	if [ -n "$CONDA_ENV" ]
	then
		if [ "$CONDA_DEFAULT_ENV" != "$CONDA_ENV" ]
		then
			conda activate "$CONDA_ENV"
		fi
		
		if [ "$CONDA_DEFAULT_ENV" != "$CONDA_ENV" ]
		then
			echo >&2 "Error: no '$CONDA_ENV' environment"
			exit 1
		fi
	fi
	
	CONDA_PATH=""
fi

################################################################################

if [ -z "$FTDMPDIR" ] || [ -n "$FTDMP_ROOT" ]
then
	if [ -z "$FTDMP_ROOT" ]
	then
		export FTDMPDIR="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
	else
		export FTDMPDIR="$FTDMP_ROOT"
	fi
	export PATH="${FTDMPDIR}/core/voronota-iface-gnn_release:${FTDMPDIR}/core/voronota-js_release:${FTDMPDIR}/core/3D_Dock/progs:${FTDMPDIR}:${PATH}"
fi

################################################################################

PREPARED_STATIC_STRUCTURE_FILE=""
PREPARED_MOBILE_STRUCTURE_FILE=""
INPUT_COMPLEX_PREFIX=""
INPUT_COMPLEX_SUFFIX=""

if [ "$DOCKING_REGIME" == "hetero" ]
then
	echo >&2 "ftdpm-all: doing hetero docking"
	
	ftdmp-all-dock \
	  --job-name                "$JOB_NAME" \
	  --static-file             "$STATIC_STRUCTURE_FILE" \
	  --static-sel              "$STATIC_STRUCTURE_SELECTION" \
	  --static-chain            "$STATIC_STRUCTURE_CHAIN" \
	  --static-rotation-seed    "$STATIC_STRUCTURE_ROTATION_SEED" \
	  --mobile-file             "$MOBILE_STRUCTURE_FILE" \
	  --mobile-sel              "$MOBILE_STRUCTURE_SELECTION" \
	  --mobile-chain            "$MOBILE_STRUCTURE_CHAIN" \
	  --mobile-rotation-seed    "$MOBILE_STRUCTURE_ROTATION_SEED" \
	  --openmm-forcefield       "$OPENMM_FORCEFIELD" \
	  --conda-path              "$CONDA_PATH" \
	  --conda-env               "$CONDA_ENV" \
	  --use-ftdock              "$USE_FTDOCK" \
	  --use-hex                 "$USE_HEX" \
	  --ftdock-keep             "$FTDOCK_KEEP" \
	  --ftdock-angle-step       "$FTDOCK_ANGLE_STEP" \
	  --ftdock-min-grid-sep     "$FTDOCK_MIN_GRID_SEP" \
	  --hex-macro-mode          "$HEX_MACRO_MODE" \
	  --hex-max-solutions       "$HEX_MAX_SOLUTIONS" \
	  --hex-script              "$HEX_SCRIPT" \
	  --hex-swap-and-repeat     "$HEX_SWAP_AND_REPEAT" \
	  --parallel                "$DOCKING_PROCESSORS" \
	  --sbatch-for-ftdock       "$DOCKING_SBATCH_FOR_FTDOCK" \
	  --sbatch-for-hex-or-sam   "$DOCKING_SBATCH_FOR_HEX_OR_SAM" \
	  --output-dir              "$OUTPUT_PATH"

	PREPARED_STATIC_STRUCTURE_FILE="${OUTPUT_PATH}/${JOB_NAME}/monomer_static.pdb"
	PREPARED_MOBILE_STRUCTURE_FILE="${OUTPUT_PATH}/${JOB_NAME}/monomer_mobile.pdb"
fi

if [ "$DOCKING_REGIME" == "homo" ]
then
	echo >&2 "ftdpm-all: doing homo docking"

	ftdmp-all-dock \
	  --job-name                "$JOB_NAME" \
	  --mobile-file             "$MOBILE_STRUCTURE_FILE" \
	  --mobile-sel              "$MOBILE_STRUCTURE_SELECTION" \
	  --mobile-chain            "$MOBILE_STRUCTURE_CHAIN" \
	  --symmetry-docking        "$SYMMETRY_DOCKING" \
	  --openmm-forcefield       "$OPENMM_FORCEFIELD" \
	  --conda-path              "$CONDA_PATH" \
	  --conda-env               "$CONDA_ENV" \
	  --sam-parameters          "$SAM_PARAMETERS" \
	  --sbatch-for-hex-or-sam   "$DOCKING_SBATCH_FOR_HEX_OR_SAM" \
	  --output-dir              "$OUTPUT_PATH"
	
	INPUT_COMPLEX_PREFIX="${OUTPUT_PATH}/${JOB_NAME}/homo_complexes/"
	INPUT_COMPLEX_SUFFIX=".pdb"
fi

if [ "$DOCKING_REGIME" == "pre-docked" ]
then
	echo >&2 "ftdpm-all: running in pre-docked mode"

	mkdir -p "${OUTPUT_PATH}/${JOB_NAME}"
	
	{
		echo "ID"
		find "$PRE_DOCKED_INPUT_DIR" -type f -name '*.pdb' -not -empty \
		| sed "s|^${PRE_DOCKED_INPUT_DIR}||" \
		| sed 's|\.pdb$||'
	} \
	> "${OUTPUT_PATH}/${JOB_NAME}/docking_results.txt"
	
	INPUT_COMPLEX_PREFIX="${PRE_DOCKED_INPUT_DIR}"
	INPUT_COMPLEX_SUFFIX=".pdb"
fi

OUTPUT_PATH="${OUTPUT_PATH}/${JOB_NAME}"

PREV_SCORING_RESULTS_FILE="${OUTPUT_PATH}/docking_results.txt"

if [ ! -s "$PREV_SCORING_RESULTS_FILE" ]
then
	echo >&2 "Error: no docking results"
	exit 1
fi

################################################################################

echo >&2 "ftdpm-all: scoring with ftdmp-all-score"

ftdmp-all-score \
  --input-from-table        "$PREV_SCORING_RESULTS_FILE" \
  --structure-monomer1      "$PREPARED_STATIC_STRUCTURE_FILE" \
  --structure-monomer2      "$PREPARED_MOBILE_STRUCTURE_FILE" \
  --structure-prefix        "$INPUT_COMPLEX_PREFIX" \
  --structure-suffix        "$INPUT_COMPLEX_SUFFIX" \
  --subselect-contacts      "$INTERFACE_SUBSELECTION" \
  --constraints-required    "$CONSTRAINTS_REQUIRED" \
  --constraints-banned      "$CONSTRAINTS_BANNED" \
  --constraint-clashes      "$CONSTRAINT_CLASHES" \
  --reference               "$REFERENCE_STRUCTURE_FILE_FOR_COMPARISON" \
  --remap-cadscore          "$REMAP_CADSCORE" \
  --mode-protein            "$SCORING_MODE_PROTEIN" \
  --mode-protein-sr         "$SCORING_MODE_PROTEIN_SIDECHAIN_REBUILT" \
  --mode-generic            "$SCORING_MODE_GENERIC" \
  --mode-generic-sr         "$SCORING_MODE_GENERIC_SIDECHAIN_REBUILT" \
  --mode-protein-gnn        "$SCORING_MODE_PROTEIN_GNN" \
  --mode-protein-gnn-sr     "$SCORING_MODE_PROTEIN_GNN_SIDECHAIN_REBUILT" \
  --mode-protein-global     "$SCORING_MODE_PROTEIN_GLOBAL" \
  --conda-path              "$CONDA_PATH" \
  --conda-env               "$CONDA_ENV_FOR_GNN" \
  --score-symmetry          "$SCORE_SYMMETRY" \
  --local-columns           "$LOCAL_COLUMNS" \
  --keep-top                "$SCORING_TOP_STAGE1" \
  --keep-top-for-slow       "$SCORING_TOP_STAGE1_FOR_SLOW" \
  --clash-tour-tolerance    "0.05" \
  --parallel                "$SCORING_PROCESSORS" \
  --cache-dir               "$CACHE_DIR" \
  --sbatch                  "$SCORING_SBATCH" \
  --output-names-prefix     "raw_" \
  --output-dir              "$OUTPUT_PATH"

PREV_SCORING_RESULTS_FILE="${OUTPUT_PATH}/raw_scoring_results_with_ranks.txt"

if [ ! -s "$PREV_SCORING_RESULTS_FILE" ]
then
	echo >&2 "Error: no raw scoring results"
	exit 1
fi

################################################################################

if [ "$ONLY_DOCK_AND_SCORE" == "true" ]
then
	exit 0
fi

################################################################################

if [ -n "$DIVERSIFY" ]
then
	echo >&2 "ftdpm-all: diversifying with ftdmp-all-diversify"
	
	ftdmp-all-diversify \
	  --input-scoring-table   "$PREV_SCORING_RESULTS_FILE" \
	  --names-prefix          "raw_" \
	  --cadscore-step         "$DIVERSIFY" \
	  --site-cadscore-step    "$DIVERSIFY" \
	  --zero-count            "5" \
	  --build-complexes       "$NUMBER_OF_COMPLEXES_TO_BUILD"
	
	exit 0
fi

################################################################################

echo >&2 "ftdpm-all: running ftdmp-all-jury"

ftdmp-all-jury \
  --input-scoring-table     "$PREV_SCORING_RESULTS_FILE" \
  --structure-monomer1      "$PREPARED_STATIC_STRUCTURE_FILE" \
  --structure-monomer2      "$PREPARED_MOBILE_STRUCTURE_FILE" \
  --structure-prefix        "$INPUT_COMPLEX_PREFIX" \
  --structure-suffix        "$INPUT_COMPLEX_SUFFIX" \
  --subselect-contacts      "$INTERFACE_SUBSELECTION" \
  --rank-names              "$SCORING_RANKS" \
  --ranks-top               "$SCORING_TOP_STAGE2" \
  --remap-cadscore          "$REMAP_CADSCORE" \
  --jury-slices             "$SCORING_RANKS_JURY_SLICES" \
  --jury-cluster            "$SCORING_RANKS_JURY_CLUSTER" \
  --jury-max-values         "$SCORING_RANKS_JURY_MAX_VALUES" \
  --redundancy-threshold    "$REDUNDANCY_THRESHOLD" \
  --parallel                "$SCORING_PROCESSORS" \
  --sbatch                  "$SCORING_SBATCH" \
  --output-names-prefix     "raw_"

PREV_SCORING_RESULTS_FILE="${OUTPUT_PATH}/raw_top_scoring_results_RJS.txt"

if [ ! -s "$PREV_SCORING_RESULTS_FILE" ]
then
	echo >&2 "Error: no raw jury results"
	exit 1
fi

################################################################################

if [ "$CASP15QA" == "true" ] && [ "$SCORING_MODE_PROTEIN_GNN" == "true" ] && [ "$LOCAL_COLUMNS" == "true" ]
then
	echo >&2 "ftdpm-all: writing answer with ftdmp-form-casp15-qa-answer"

	ftdmp-form-casp15-qa-answer \
	  --input-scoring-table "$PREV_SCORING_RESULTS_FILE" \
	  --prefix-for-gnn-scores 'raw_FIGNN' \
	  --prefix-for-jury-scores 'raw_RJS' \
	  --target-name "$CASP15QA_TARGET" \
	  --author-id "$CASP15QA_AUTHOR" \
	> "${OUTPUT_PATH}/raw_casp15_qa_answer.txt"
fi

if [ "$PLOT_JURY_SCORES" == "true" ]
then
	echo >&2 "ftdpm-all: plotting with ftdmp-plot-jury-scores"
	
	ftdmp-plot-jury-scores \
	  --input-scoring-table "$PREV_SCORING_RESULTS_FILE" \
	  --prefix-for-jury-scores 'raw_RJS' \
	  --output "${OUTPUT_PATH}/raw_RJS_plot.png"
fi

################################################################################

if [ "$NUMBER_OF_COMPLEXES_TO_BUILD" -gt "0" ]
then
	NEXT_SCORING_RESULTS_FILE="${OUTPUT_PATH}/raw_top_built_results.txt"
	
	TOP_COMPLEXES_DIR="${OUTPUT_PATH}/raw_top_complexes"
	
	if [ "$DOCKING_REGIME" == "hetero" ]
	then
		echo >&2 "ftdpm-all: building top hetero complexes"
		
		TOP_COMPLEXES_RAW_DIR="${OUTPUT_PATH}/raw_top_complexes_raw"
		
		{
		cat "$PREV_SCORING_RESULTS_FILE"
		cat "$PREPARED_STATIC_STRUCTURE_FILE"
		cat "$PREPARED_MOBILE_STRUCTURE_FILE"
		echo "$NUMBER_OF_COMPLEXES_TO_BUILD"
		echo "$MULTIPLY_CHAINS"
		} | ftdmp-check-hash --hash-file "${OUTPUT_PATH}/input_hashes/$(basename "$NEXT_SCORING_RESULTS_FILE")" --dependent-file "$NEXT_SCORING_RESULTS_FILE"
		
		if [ ! -s "$NEXT_SCORING_RESULTS_FILE" ]
		then
			rm -rf "$TOP_COMPLEXES_DIR"
			rm -rf "$TOP_COMPLEXES_RAW_DIR"
			
			cat "$PREV_SCORING_RESULTS_FILE" \
			| head -n "$((NUMBER_OF_COMPLEXES_TO_BUILD+1))" \
			| ftdmp-build-complex --monomer1 "$PREPARED_STATIC_STRUCTURE_FILE" --monomer2 "$PREPARED_MOBILE_STRUCTURE_FILE" \
			  --output-prefix "${TOP_COMPLEXES_DIR}/" \
			  --output-suffix ".pdb" \
			> "$NEXT_SCORING_RESULTS_FILE"
			
			if [ -n "$MULTIPLY_CHAINS" ]
			then
				mv "$TOP_COMPLEXES_DIR" "$TOP_COMPLEXES_RAW_DIR"
				
				cat "$NEXT_SCORING_RESULTS_FILE" \
				| tail -n +2 \
				| awk -v inputprefix="${TOP_COMPLEXES_RAW_DIR}/" -v outputprefix="${TOP_COMPLEXES_DIR}/" -v suffix=".pdb" \
				  '{print inputprefix $1 suffix " " outputprefix $1 suffix}' \
				| xargs -L 1 -P "$SCORING_PROCESSORS" bash -c "ftdmp-multiply-chains $MULTIPLY_CHAINS --input \$0 --output \$1"
				
				rm -rf "$TOP_COMPLEXES_RAW_DIR"
			fi
		fi
	fi
	
	if [ "$DOCKING_REGIME" == "homo" ] || [ "$DOCKING_REGIME" == "pre-docked" ]
	then
		echo >&2 "ftdpm-all: copying top homo or pre-docked complexes"
	
		{
		cat "$PREV_SCORING_RESULTS_FILE"
		echo "$NUMBER_OF_COMPLEXES_TO_BUILD"
		} | ftdmp-check-hash --hash-file "${OUTPUT_PATH}/input_hashes/$(basename "$NEXT_SCORING_RESULTS_FILE")" --dependent-file "$NEXT_SCORING_RESULTS_FILE"
		
		if [ ! -s "$NEXT_SCORING_RESULTS_FILE" ]
		then
			rm -rf "$TOP_COMPLEXES_DIR"
			
			cat "$PREV_SCORING_RESULTS_FILE" \
			| ftdmp-extract-table-columns ID \
			| tail -n +2 \
			| head -n "$NUMBER_OF_COMPLEXES_TO_BUILD" \
			| while read -r IDTOCOPY
			do
				mkdir -p "$(dirname ${TOP_COMPLEXES_DIR}/${IDTOCOPY})"
				cp "${INPUT_COMPLEX_PREFIX}${IDTOCOPY}${INPUT_COMPLEX_SUFFIX}" "${TOP_COMPLEXES_DIR}/${IDTOCOPY}.pdb"
			done
			
			cat "$PREV_SCORING_RESULTS_FILE" \
			| head -n "$((NUMBER_OF_COMPLEXES_TO_BUILD+1))" \
			> "$NEXT_SCORING_RESULTS_FILE"
		fi
	fi
	
	PREV_SCORING_RESULTS_FILE="$NEXT_SCORING_RESULTS_FILE"
fi

################################################################################

if [ "$NUMBER_OF_COMPLEXES_TO_BUILD" -lt "1" ] || [ -z "$RELAX_COMPLEXES" ] || [ "$RELAX_COMPLEXES" == "false" ]
then
	exit 0
fi

################################################################################

echo >&2 "ftdpm-all: relaxing complexes with ftdmp-relax-with-openmm"

TOP_RELAXED_COMPLEXES_DIR="${OUTPUT_PATH}/relaxed_top_complexes"

cat "$PREV_SCORING_RESULTS_FILE" \
| tail -n +2 \
| awk -v inputprefix="${TOP_COMPLEXES_DIR}/" -v outputprefix="${TOP_RELAXED_COMPLEXES_DIR}/" -v suffix=".pdb" '{print inputprefix $1 suffix " " outputprefix $1 suffix}' \
| while read UNRELAXEDFILE RELAXEDFILE
do
	{
	cat "$UNRELAXEDFILE"
	echo "$OPENMM_FORCEFIELD"
	echo "$RELAX_COMPLEXES"
	} | ftdmp-check-hash --hash-file "${OUTPUT_PATH}/input_hashes/relaxed_top_complexes/$(basename "$RELAXEDFILE")" --dependent-file "$RELAXEDFILE"
	
	if [ ! -s "$RELAXEDFILE" ]
	then
		echo "${UNRELAXEDFILE} ${RELAXEDFILE}" \
		| awk -v relaxoptions="--forcefield '$OPENMM_FORCEFIELD' --conda-path '$CONDA_PATH' --conda-env '$CONDA_ENV' --cache-dir '$CACHE_DIR' --no-preparation $RELAX_COMPLEXES" \
		  '{print "ftdmp-relax-with-openmm " relaxoptions " --input " $1 " --output " $2}' \
		| bash
	fi
done

if [ "$(find $TOP_RELAXED_COMPLEXES_DIR -type f -name '*.pdb' -not -empty | wc -l)" -lt "2" ]
then
	echo >&2 "Error: failed to relax top complexes"
	exit 1
fi

################################################################################

echo >&2 "ftdpm-all: scoring relaxed complexes with ftdmp-all-score"

ftdmp-all-score \
  --input-from-table        "$PREV_SCORING_RESULTS_FILE" \
  --structure-prefix        "${TOP_RELAXED_COMPLEXES_DIR}/" \
  --structure-suffix        ".pdb" \
  --subselect-contacts      "$INTERFACE_SUBSELECTION" \
  --constraints-required    "$CONSTRAINTS_REQUIRED" \
  --constraints-banned      "$CONSTRAINTS_BANNED" \
  --constraint-clashes      "$CONSTRAINT_CLASHES" \
  --reference               "$REFERENCE_STRUCTURE_FILE_FOR_COMPARISON" \
  --remap-cadscore          "$REMAP_CADSCORE" \
  --mode-protein            "$SCORING_MODE_PROTEIN" \
  --mode-protein-sr         "$SCORING_MODE_PROTEIN_SIDECHAIN_REBUILT" \
  --mode-generic            "$SCORING_MODE_GENERIC" \
  --mode-generic-sr         "$SCORING_MODE_GENERIC_SIDECHAIN_REBUILT"  \
  --mode-protein-gnn        "$SCORING_MODE_PROTEIN_GNN" \
  --mode-protein-gnn-sr     "$SCORING_MODE_PROTEIN_GNN_SIDECHAIN_REBUILT" \
  --mode-protein-global     "$SCORING_MODE_PROTEIN_GLOBAL" \
  --conda-path              "$CONDA_PATH" \
  --conda-env               "$CONDA_ENV_FOR_GNN" \
  --score-symmetry          "$SCORE_SYMMETRY" \
  --local-columns           "$LOCAL_COLUMNS" \
  --keep-top                "$SCORING_TOP_STAGE1" \
  --keep-top-for-slow       "$SCORING_TOP_STAGE1_FOR_SLOW" \
  --clash-tour-tolerance    "0.01" \
  --parallel                "$SCORING_PROCESSORS" \
  --cache-dir               "$CACHE_DIR" \
  --sbatch                  "$SCORING_SBATCH" \
  --output-names-prefix     "relaxed_" \
  --output-dir              "$OUTPUT_PATH"

PREV_SCORING_RESULTS_FILE="${OUTPUT_PATH}/relaxed_scoring_results_with_ranks.txt"

if [ ! -s "$PREV_SCORING_RESULTS_FILE" ]
then
	echo >&2 "Error: no relaxed scoring results"
	exit 1
fi

################################################################################

echo >&2 "ftdpm-all: running ftdmp-all-jury for scored relaxed complexes"

RELAXED_SCORING_RANKS="$(echo "$SCORING_RANKS" | sed 's/\s\+/\n/g' | sed 's/^raw_/relaxed_/' | tr '\n' ' ')"

ftdmp-all-jury \
  --input-scoring-table     "$PREV_SCORING_RESULTS_FILE" \
  --structure-prefix        "${TOP_RELAXED_COMPLEXES_DIR}/" \
  --structure-suffix        ".pdb" \
  --subselect-contacts      "$INTERFACE_SUBSELECTION" \
  --rank-names              "$SCORING_RANKS $RELAXED_SCORING_RANKS" \
  --ranks-top               "999999" \
  --remap-cadscore          "$REMAP_CADSCORE" \
  --jury-slices             "$SCORING_RANKS_JURY_SLICES" \
  --jury-cluster            "$SCORING_RANKS_JURY_CLUSTER" \
  --jury-max-values         "$SCORING_RANKS_JURY_MAX_VALUES" \
  --redundancy-threshold    "$REDUNDANCY_THRESHOLD" \
  --parallel                "$SCORING_PROCESSORS" \
  --sbatch                  "$SCORING_SBATCH" \
  --output-names-prefix     "relaxed_"

PREV_SCORING_RESULTS_FILE="${OUTPUT_PATH}/relaxed_top_scoring_results_RJS.txt"

if [ ! -s "$PREV_SCORING_RESULTS_FILE" ]
then
	echo >&2 "Error: no relaxed jury results"
	exit 1
fi

################################################################################

if [ "$CASP15QA" == "true" ] && [ "$SCORING_MODE_PROTEIN_GNN" == "true" ] && [ "$LOCAL_COLUMNS" == "true" ]
then
	echo >&2 "ftdpm-all: writing answer for relaxed complexes with ftdmp-form-casp15-qa-answer"

	ftdmp-form-casp15-qa-answer \
	  --input-scoring-table "$PREV_SCORING_RESULTS_FILE" \
	  --prefix-for-gnn-scores 'relaxed_FIGNN' \
	  --prefix-for-jury-scores 'relaxed_RJS' \
	  --target-name "$CASP15QA_TARGET" \
	  --author-id "$CASP15QA_AUTHOR" \
	> "${OUTPUT_PATH}/relaxed_casp15_qa_answer.txt"
fi

if [ "$PLOT_JURY_SCORES" == "true" ]
then
	echo >&2 "ftdpm-all: plotting for relaxed complexes with ftdmp-plot-jury-scores"
	
	ftdmp-plot-jury-scores \
	  --input-scoring-table "$PREV_SCORING_RESULTS_FILE" \
	  --prefix-for-jury-scores 'relaxed_RJS' \
	  --output "${OUTPUT_PATH}/relaxed_RJS_plot.png"
fi

################################################################################

