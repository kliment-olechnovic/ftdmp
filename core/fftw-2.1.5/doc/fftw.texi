\input texinfo   @c -*- texinfo -*-
@c % $Id: fftw.texi,v 1.256 2003/01/15 21:09:33 stevenj Exp $
@c %**start of header
@setfilename fftw.info
@settitle FFTW
@c %**end of header

@include version.texi
@setchapternewpage odd
@c define constant index (ct)
@defcodeindex ct
@syncodeindex ct fn
@syncodeindex vr fn
@syncodeindex pg fn
@syncodeindex tp fn
@c define foreign function index (ff)
@defcodeindex ff
@syncodeindex ff cp
@c define foreign constant index (fc)
@defcodeindex fc
@syncodeindex fc cp
@c define foreign program index (fp)
@defcodeindex fp
@syncodeindex fp cp

@ifinfo
This is the FFTW User's manual.

Copyright @copyright{} 1997--1999 Massachusetts Institute of Technology

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end ifinfo

@titlepage
@sp 10
@comment The title is printed in a large font.
@title{FFTW User's Manual}
@subtitle For version @value{VERSION}, @value{UPDATED}
@author{Matteo Frigo}
@author{Steven G. Johnson}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1997--1999 Massachusetts Institute of Technology.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end titlepage

@node    Top, Introduction, (dir), (dir)
@ifinfo
@top FFTW User Manual
Welcome to FFTW, the Fastest Fourier Transform in the West.  FFTW is a
collection of fast C routines to compute the discrete Fourier transform.
This manual documents FFTW version @value{VERSION}.
@end ifinfo

@menu
* Introduction::                
* Tutorial::                    
* FFTW Reference::              
* Parallel FFTW::               
* Calling FFTW from Fortran::   
* Installation and Customization::  
* Acknowledgments::             
* License and Copyright::       
* Concept Index::               
* Library Index::               

@detailmenu --- The Detailed Node Listing ---

Tutorial

* Complex One-dimensional Transforms Tutorial::  
* Complex Multi-dimensional Transforms Tutorial::  
* Real One-dimensional Transforms Tutorial::  
* Real Multi-dimensional Transforms Tutorial::  
* Multi-dimensional Array Format::  
* Words of Wisdom::             

Multi-dimensional Array Format

* Row-major Format::            
* Column-major Format::         
* Static Arrays in C::          
* Dynamic Arrays in C::         
* Dynamic Arrays in C-The Wrong Way::  

Words of Wisdom

* Caveats in Using Wisdom::     What you should worry about in using wisdom
* Importing and Exporting Wisdom::  I/O of wisdom to disk and other media

FFTW Reference

* Data Types::                  real, complex, and halfcomplex numbers
* One-dimensional Transforms Reference::  
* Multi-dimensional Transforms Reference::  
* Real One-dimensional Transforms Reference::  
* Real Multi-dimensional Transforms Reference::  
* Wisdom Reference::            
* Memory Allocator Reference::  
* Thread safety::               

One-dimensional Transforms Reference

* fftw_create_plan::            Plan Creation
* Discussion on Specific Plans::  
* fftw::                        Plan Execution
* fftw_destroy_plan::           Plan Destruction
* What FFTW Really Computes::   Definition of the DFT.

Multi-dimensional Transforms Reference

* fftwnd_create_plan::          Plan Creation
* fftwnd::                      Plan Execution
* fftwnd_destroy_plan::         Plan Destruction
* What FFTWND Really Computes::  

Real One-dimensional Transforms Reference

* rfftw_create_plan::           Plan Creation   
* rfftw::                       Plan Execution  
* rfftw_destroy_plan::          Plan Destruction
* What RFFTW Really Computes::  

Real Multi-dimensional Transforms Reference

* rfftwnd_create_plan::         Plan Creation
* rfftwnd::                     Plan Execution
* Array Dimensions for Real Multi-dimensional Transforms::  
* Strides in In-place RFFTWND::  
* rfftwnd_destroy_plan::        Plan Destruction
* What RFFTWND Really Computes::  

Wisdom Reference

* fftw_export_wisdom::          
* fftw_import_wisdom::          
* fftw_forget_wisdom::          

Parallel FFTW

* Multi-threaded FFTW::         
* MPI FFTW::                    

Multi-threaded FFTW

* Installation and Supported Hardware/Software::  
* Usage of Multi-threaded FFTW::  
* How Many Threads to Use?::    
* Using Multi-threaded FFTW in a Multi-threaded Program::  
* Tips for Optimal Threading::  

MPI FFTW

* MPI FFTW Installation::       
* Usage of MPI FFTW for Complex Multi-dimensional Transforms::  
* MPI Data Layout::             
* Usage of MPI FFTW for Real Multi-dimensional Transforms::  
* Usage of MPI FFTW for Complex One-dimensional Transforms::  
* MPI Tips::                    

Calling FFTW from Fortran

* Wrapper Routines::            
* FFTW Constants in Fortran::   
* Fortran Examples::            

Installation and Customization

* Installation on Unix::        
* Installation on non-Unix Systems::  
* Installing FFTW in both single and double precision::  
* gcc and Pentium hacks::  
* Customizing the timer::       
* Generating your own code::    

@end detailmenu
@end menu

@c ************************************************************
@node    Introduction, Tutorial, Top, Top
@chapter Introduction
This manual documents version @value{VERSION} of FFTW, the @emph{Fastest
Fourier Transform in the West}.  FFTW is a comprehensive collection of
fast C routines for computing the discrete Fourier transform (DFT) in
one or more dimensions, of both real and complex data, and of arbitrary
input size.  FFTW also includes parallel transforms for both shared- and
distributed-memory systems.  We assume herein that the reader is already
familiar with the properties and uses of the DFT that are relevant to
her application.  Otherwise, see e.g. @cite{The Fast Fourier Transform}
by E. O. Brigham (Prentice-Hall, Englewood Cliffs, NJ, 1974).
@uref{http://www.fftw.org, Our web page} also has links to
FFT-related information online.
@cindex FFTW

FFTW is usually faster (and sometimes much faster) than all other
freely-available Fourier transform programs found on the Net.  For
transforms whose size is a power of two, it compares favorably with the
FFT codes in Sun's Performance Library and IBM's ESSL library, which are
targeted at specific machines.  Moreover, FFTW's performance is
@emph{portable}.  Indeed, FFTW is unique in that it automatically adapts
itself to your machine, your cache, the size of your memory, the number
of registers, and all the other factors that normally make it impossible
to optimize a program for more than one machine.  An extensive
comparison of FFTW's performance with that of other Fourier transform
codes has been made. The results are available on the Web at
@uref{http://theory.lcs.mit.edu/~benchfft, the benchFFT home page}.
@cindex benchmark
@fpindex benchfft

In order to use FFTW effectively, you need to understand one basic
concept of FFTW's internal structure.  FFTW does not used a fixed
algorithm for computing the transform, but it can adapt the DFT
algorithm to details of the underlying hardware in order to achieve best
performance.  Hence, the computation of the transform is split into two
phases.  First, FFTW's @dfn{planner} is called, which ``learns'' the
@cindex plan
fastest way to compute the transform on your machine.  The planner
@cindex planner
produces a data structure called a @dfn{plan} that contains this
information.  Subsequently, the plan is passed to FFTW's @dfn{executor},
@cindex executor
along with an array of input data.  The executor computes the actual
transform, as dictated by the plan.  The plan can be reused as many
times as needed.  In typical high-performance applications, many
transforms of the same size are computed, and consequently a
relatively-expensive initialization of this sort is acceptable.  On the
other hand, if you need a single transform of a given size, the one-time
cost of the planner becomes significant.  For this case, FFTW provides
fast planners based on heuristics or on previously computed plans.

The pattern of planning/execution applies to all four operation modes of
FFTW, that is, @w{I) one-dimensional} complex transforms (FFTW), @w{II)
multi-dimensional} complex transforms (FFTWND), @w{III) one-dimensional}
transforms of real data (RFFTW), @w{IV) multi-dimensional} transforms of
real data (RFFTWND).  Each mode comes with its own planner and executor.

Besides the automatic performance adaptation performed by the planner,
it is also possible for advanced users to customize FFTW for their
special needs.  As distributed, FFTW works most efficiently for arrays
whose size can be factored into small primes (@math{2}, @math{3},
@math{5}, and @math{7}), and uses a slower general-purpose routine for
other factors.  FFTW, however, comes with a code generator that can
produce fast C programs for any particular array size you may care
about.
@cindex code generator
For example, if you need transforms of size
@ifinfo
@math{513 = 19 x 3^3},
@end ifinfo
@tex
$513 = 19 \cdot 3^3$,
@end tex
@ifhtml
513&nbsp;=&nbsp;19*3<sup>3</sup>,
@end ifhtml
you can customize FFTW to support the factor @math{19} efficiently.

FFTW can exploit multiple processors if you have them.  FFTW comes with
a shared-memory implementation on top of POSIX (and similar) threads, as
well as a distributed-memory implementation based on MPI.
@cindex parallel transform
@cindex threads
@cindex MPI
We also provide an experimental parallel implementation written in Cilk,
@emph{the superior programming tool of choice for discriminating
hackers} (Olin Shivers).  (See @uref{http://supertech.lcs.mit.edu/cilk,
the Cilk home page}.)
@cindex Cilk

For more information regarding FFTW, see the paper, ``The Fastest
Fourier Transform in the West,'' by M. Frigo and S. G. Johnson, which is
the technical report MIT-LCS-TR-728 (Sep. '97).  See also, ``FFTW: An
Adaptive Software Architecture for the FFT,'' by M. Frigo and
S. G. Johnson, which appeared in the 23rd International Conference on
Acoustics, Speech, and Signal Processing (@cite{Proc. ICASSP 1998}
@b{3}, p. 1381).  The code generator is described in the paper ``A Fast
Fourier Transform Compiler'', 
@cindex compiler
by M. Frigo, to appear in the @cite{Proceedings of the 1999 ACM SIGPLAN
Conference on Programming Language Design and Implementation (PLDI),
Atlanta, Georgia, May 1999}.  These papers, along with the latest
version of FFTW, the FAQ, benchmarks, and other links, are available at
@uref{http://www.fftw.org, the FFTW home page}.  The current
version of FFTW incorporates many good ideas from the past thirty years
of FFT literature.  In one way or another, FFTW uses the Cooley-Tukey
algorithm, the Prime Factor algorithm, Rader's algorithm for prime
sizes, and the split-radix algorithm (with a variation due to Dan
Bernstein).  Our code generator also produces new algorithms that we do
not yet completely understand.
@cindex algorithm
The reader is referred to the cited papers for the appropriate
references.

The rest of this manual is organized as follows.  We first discuss the
sequential (one-processor) implementation.  We start by describing the
basic features of FFTW in @ref{Tutorial}.  This discussion includes the
storage scheme of multi-dimensional arrays (@ref{Multi-dimensional Array
Format}) and FFTW's mechanisms for storing plans on disk (@ref{Words of
Wisdom}).  Next, @ref{FFTW Reference} provides comprehensive
documentation of all FFTW's features.  Parallel transforms are discussed
in their own chapter @ref{Parallel FFTW}.  Fortran programmers can also
use FFTW, as described in @ref{Calling FFTW from Fortran}.
@ref{Installation and Customization} explains how to install FFTW in
your computer system and how to adapt FFTW to your needs.  License and
copyright information is given in @ref{License and Copyright}.  Finally,
we thank all the people who helped us in @ref{Acknowledgments}.

@c ************************************************************
@node  Tutorial, FFTW Reference, Introduction, Top
@chapter Tutorial
@cindex Tutorial
This chapter describes the basic usage of FFTW, i.e., how to compute the
Fourier transform of a single array.  This chapter tells the truth, but
not the @emph{whole} truth. Specifically, FFTW implements additional
routines and flags, providing extra functionality, that are not
documented here.  @xref{FFTW Reference}, for more complete information.
(Note that you need to compile and install FFTW before you can use it in
a program.  @xref{Installation and Customization}, for the details of
the installation.)

Here, we assume a default installation of FFTW.  In some installations
(particulary from binary packages), the FFTW header files and libraries
are prefixed with @samp{@code{d}} or @samp{@code{s}} to indicate
versions in double or single precision, respectively.  The usage of FFTW
in that case is the same, except that @code{#include} directives and
link commands must use the appropriate prefix.  @xref{Installing FFTW in
both single and double precision}, for more information.

This tutorial chapter is structured as follows.  @ref{Complex
One-dimensional Transforms Tutorial} describes the basic usage of the
one-dimensional transform of complex data.  @ref{Complex
Multi-dimensional Transforms Tutorial} describes the basic usage of the
multi-dimensional transform of complex data.  @ref{Real One-dimensional
Transforms Tutorial} describes the one-dimensional transform of real
data and its inverse.  Finally, @ref{Real Multi-dimensional Transforms
Tutorial} describes the multi-dimensional transform of real data and its
inverse.  We recommend that you read these sections in the order that
they are presented.  We then discuss two topics in detail.  In
@ref{Multi-dimensional Array Format}, we discuss the various
alternatives for storing multi-dimensional arrays in memory.  @ref{Words
of Wisdom} shows how you can save FFTW's plans for future use.

@menu
* Complex One-dimensional Transforms Tutorial::  
* Complex Multi-dimensional Transforms Tutorial::  
* Real One-dimensional Transforms Tutorial::  
* Real Multi-dimensional Transforms Tutorial::  
* Multi-dimensional Array Format::  
* Words of Wisdom::             
@end menu

@node  Complex One-dimensional Transforms Tutorial, Complex Multi-dimensional Transforms Tutorial, Tutorial, Tutorial
@section Complex One-dimensional Transforms Tutorial
@cindex complex one-dimensional transform
@cindex complex transform

The basic usage of FFTW is simple.  A typical call to FFTW looks like:

@example
#include <fftw.h>
...
@{
     fftw_complex in[N], out[N];
     fftw_plan p;
     ...
     p = fftw_create_plan(N, FFTW_FORWARD, FFTW_ESTIMATE);
     ...
     fftw_one(p, in, out);
     ...
     fftw_destroy_plan(p);  
@}
@end example

The first thing we do is to create a @dfn{plan}, which is an object
@cindex plan
that contains all the data that FFTW needs to compute the FFT, using the
following function:

@example
fftw_plan fftw_create_plan(int n, fftw_direction dir, int flags);
@end example
@findex fftw_create_plan
@findex fftw_direction
@tindex fftw_plan

The first argument, @code{n}, is the size of the transform you are
trying to compute.  The size @code{n} can be any positive integer, but
sizes that are products of small factors are transformed most
efficiently.  The second argument, @code{dir}, can be either
@code{FFTW_FORWARD} or @code{FFTW_BACKWARD}, and indicates the direction
of the transform you
@ctindex FFTW_FORWARD
@ctindex FFTW_BACKWARD
are interested in.  Alternatively, you can use the sign of the exponent
in the transform, @math{-1} or @math{+1}, which corresponds to
@code{FFTW_FORWARD} or @code{FFTW_BACKWARD} respectively.  The
@code{flags} argument is either @code{FFTW_MEASURE} or
@cindex flags
@code{FFTW_ESTIMATE}.  @code{FFTW_MEASURE} means that FFTW actually runs
@ctindex FFTW_MEASURE
and measures the execution time of several FFTs in order to find the
best way to compute the transform of size @code{n}.  This may take some
time, depending on your installation and on the precision of the timer
in your machine.  @code{FFTW_ESTIMATE}, on the contrary, does not run
any computation, and just builds a
@ctindex FFTW_ESTIMATE
reasonable plan, which may be sub-optimal.  In other words, if your
program performs many transforms of the same size and initialization
time is not important, use @code{FFTW_MEASURE}; otherwise use the
estimate.  (A compromise between these two extremes exists.  @xref{Words
of Wisdom}.)

Once the plan has been created, you can use it as many times as you like
for transforms on arrays of the same size.  When you are done with the
plan, you deallocate it by calling @code{fftw_destroy_plan(plan)}.
@findex fftw_destroy_plan

The transform itself is computed by passing the plan along with the
input and output arrays to @code{fftw_one}:

@example
void fftw_one(fftw_plan plan, fftw_complex *in, fftw_complex *out);
@end example
@findex fftw_one

Note that the transform is out of place: @code{in} and @code{out} must
point to distinct arrays. It operates on data of type
@code{fftw_complex}, a data structure with real (@code{in[i].re}) and
imaginary (@code{in[i].im}) floating-point components.  The @code{in}
and @code{out} arrays should have the length specified when the plan was
created.  An alternative function, @code{fftw}, allows you to
efficiently perform multiple and/or strided transforms (@pxref{FFTW
Reference}).
@tindex fftw_complex

The DFT results are stored in-order in the array @code{out}, with the
zero-frequency (DC) component in @code{out[0]}.
@cindex frequency
The array @code{in} is not modified.  Users should note that FFTW
computes an unnormalized DFT, the sign of whose exponent is given by the
@code{dir} parameter of @code{fftw_create_plan}.  Thus, computing a
forward followed by a backward transform (or vice versa) results in the
original array scaled by @code{n}.  @xref{What FFTW Really Computes},
for the definition of DFT.
@cindex normalization

A program using FFTW should be linked with @code{-lfftw -lm} on Unix
systems, or with the FFTW and standard math libraries in general.
@cindex linking on Unix

@node Complex Multi-dimensional Transforms Tutorial, Real One-dimensional Transforms Tutorial, Complex One-dimensional Transforms Tutorial, Tutorial
@section Complex Multi-dimensional Transforms Tutorial
@cindex complex multi-dimensional transform
@cindex multi-dimensional transform

FFTW can also compute transforms of any number of dimensions
(@dfn{rank}).  The syntax is similar to that for the one-dimensional
@cindex rank
transforms, with @samp{fftw_} replaced by @samp{fftwnd_} (which stands
for ``@code{fftw} in @code{N} dimensions'').

As before, we @code{#include <fftw.h>} and create a plan for the
transforms, this time of type @code{fftwnd_plan}:

@example
fftwnd_plan fftwnd_create_plan(int rank, const int *n,
                               fftw_direction dir, int flags);
@end example
@tindex fftwnd_plan
@tindex fftw_direction
@findex fftwnd_create_plan

@code{rank} is the dimensionality of the array, and can be any
non-negative integer.  The next argument, @code{n}, is a pointer to an
integer array of length @code{rank} containing the (positive) sizes of
each dimension of the array.  (Note that the array will be stored in
row-major order. @xref{Multi-dimensional Array Format}, for information
on row-major order.)  The last two parameters are the same as in
@code{fftw_create_plan}.  We now, however, have an additional possible
flag, @code{FFTW_IN_PLACE}, since @code{fftwnd} supports true in-place
@cindex flags
@ctindex FFTW_IN_PLACE
@findex fftwnd
transforms.  Multiple flags are combined using a bitwise @dfn{or}
(@samp{|}).  (An @dfn{in-place} transform is one in which the output
data overwrite the input data.  It thus requires half as much memory
as---and is often faster than---its opposite, an @dfn{out-of-place}
transform.)
@cindex in-place transform
@cindex out-of-place transform

For two- and three-dimensional transforms, FFTWND provides alternative
routines that accept the sizes of each dimension directly, rather than
indirectly through a rank and an array of sizes.  These are otherwise
identical to @code{fftwnd_create_plan}, and are sometimes more
convenient:

@example
fftwnd_plan fftw2d_create_plan(int nx, int ny,
                               fftw_direction dir, int flags);
fftwnd_plan fftw3d_create_plan(int nx, int ny, int nz,
                               fftw_direction dir, int flags);
@end example
@findex fftw2d_create_plan
@findex fftw3d_create_plan

Once the plan has been created, you can use it any number of times for
transforms of the same size.  When you do not need a plan anymore, you
can deallocate the plan by calling @code{fftwnd_destroy_plan(plan)}.
@findex fftwnd_destroy_plan

Given a plan, you can compute the transform of an array of data by
calling:

@example
void fftwnd_one(fftwnd_plan plan, fftw_complex *in, fftw_complex *out);
@end example
@findex fftwnd_one

Here, @code{in} and @code{out} point to multi-dimensional arrays in
row-major order, of the size specified when the plan was created.  In
the case of an in-place transform, the @code{out} parameter is ignored
and the output data are stored in the @code{in} array.  The results are
stored in-order, unnormalized, with the zero-frequency component in
@code{out[0]}.
@cindex frequency
A forward followed by a backward transform (or vice-versa) yields the
original data multiplied by the size of the array (i.e. the product of
the dimensions).  @xref{What FFTWND Really Computes}, for a discussion
of what FFTWND computes.
@cindex normalization

For example, code to perform an in-place FFT of a three-dimensional
array might look like:

@example
#include <fftw.h>
...
@{
     fftw_complex in[L][M][N];
     fftwnd_plan p;
     ...
     p = fftw3d_create_plan(L, M, N, FFTW_FORWARD,
                            FFTW_MEASURE | FFTW_IN_PLACE);
     ...
     fftwnd_one(p, &in[0][0][0], NULL);
     ...
     fftwnd_destroy_plan(p);  
@}
@end example

Note that @code{in} is a statically-declared array, which is
automatically in row-major order, but we must take the address of the
first element in order to fit the type expected by @code{fftwnd_one}.
(@xref{Multi-dimensional Array Format}.)

@node Real One-dimensional Transforms Tutorial, Real Multi-dimensional Transforms Tutorial, Complex Multi-dimensional Transforms Tutorial, Tutorial
@section Real One-dimensional Transforms Tutorial
@cindex real transform
@cindex complex to real transform
@cindex RFFTW

If the input data are purely real, you can save roughly a factor of two
in both time and storage by using the @dfn{rfftw} transforms, which are
FFTs specialized for real data.  The output of a such a transform is a
@dfn{halfcomplex} array, which consists of only half of the complex DFT
amplitudes (since the negative-frequency amplitudes for real data are
the complex conjugate of the positive-frequency amplitudes).
@cindex halfcomplex array

In exchange for these speed and space advantages, the user sacrifices
some of the simplicity of FFTW's complex transforms.  First of all, to
allow maximum performance, the output format of the one-dimensional real
transforms is different from that used by the multi-dimensional
transforms.  Second, the inverse transform (halfcomplex to real) has the
side-effect of destroying its input array.  Neither of these
inconveniences should pose a serious problem for users, but it is
important to be aware of them.  (Both the inconvenient output format
and the side-effect of the inverse transform can be ameliorated for
one-dimensional transforms, at the expense of some performance, by using
instead the multi-dimensional transform routines with a rank of one.)

The computation of the plan is similar to that for the complex
transforms.  First, you @code{#include <rfftw.h>}.  Then, you create a
plan (of type @code{rfftw_plan}) by calling:

@example
rfftw_plan rfftw_create_plan(int n, fftw_direction dir, int flags);
@end example
@tindex rfftw_plan
@tindex fftw_direction
@findex rfftw_create_plan

@code{n} is the length of the @emph{real} array in the transform (even
for halfcomplex-to-real transforms), and can be any positive integer
(although sizes with small factors are transformed more efficiently).
@code{dir} is either @code{FFTW_REAL_TO_COMPLEX} or
@code{FFTW_COMPLEX_TO_REAL}.
@ctindex FFTW_REAL_TO_COMPLEX
@ctindex FFTW_COMPLEX_TO_REAL
The @code{flags} parameter is the same as in @code{fftw_create_plan}.

Once created, a plan can be used for any number of transforms, and is
deallocated when you are done with it by calling
@code{rfftw_destroy_plan(plan)}.
@findex rfftw_destroy_plan

Given a plan, a real-to-complex or complex-to-real transform is computed
by calling:

@example
void rfftw_one(rfftw_plan plan, fftw_real *in, fftw_real *out);
@end example
@findex rfftw_one

(Note that @code{fftw_real} is an alias for the floating-point type for
which FFTW was compiled.)  Depending upon the direction of the plan,
either the input or the output array is halfcomplex, and is stored in
the following format:
@cindex halfcomplex array

@tex
$$
r_0, r_1, r_2, \ldots, r_{n/2}, i_{(n+1)/2-1}, \ldots, i_2, i_1
$$
@end tex
@ifinfo
r0, r1, r2, r(n/2), i((n+1)/2-1), ..., i2, i1
@end ifinfo
@ifhtml
<p align=center>
r<sub>0</sub>, r<sub>1</sub>, r<sub>2</sub>, ..., r<sub>n/2</sub>, i<sub>(n+1)/2-1</sub>, ..., i<sub>2</sub>, i<sub>1</sub>
</p>
@end ifhtml

Here,
@ifinfo
rk
@end ifinfo
@tex
$r_k$
@end tex
@ifhtml
r<sub>k</sub>
@end ifhtml
is the real part of the @math{k}th output, and
@ifinfo
ik
@end ifinfo
@tex
$i_k$
@end tex
@ifhtml
i<sub>k</sub>
@end ifhtml
is the imaginary part.  (We follow here the C convention that integer
division is rounded down, e.g. @math{7 / 2 = 3}.) For a halfcomplex
array @code{hc[]}, the @math{k}th component has its real part in
@code{hc[k]} and its imaginary part in @code{hc[n-k]}, with the
exception of @code{k} @code{==} @code{0} or @code{n/2} (the latter only
if n is even)---in these two cases, the imaginary part is zero due to
symmetries of the real-complex transform, and is not stored.  Thus, the
transform of @code{n} real values is a halfcomplex array of length
@code{n}, and vice versa.  @footnote{The output for the
multi-dimensional rfftw is a more-conventional array of
@code{fftw_complex} values, but the format here permitted us greater
efficiency in one dimension.}  This is actually only half of the DFT
spectrum of the data.  Although the other half can be obtained by
complex conjugation, it is not required by many applications such as
convolution and filtering.

Like the complex transforms, the RFFTW transforms are unnormalized, so a
forward followed by a backward transform (or vice-versa) yields the
original data scaled by the length of the array, @code{n}.
@cindex normalization

Let us reiterate here our warning that an @code{FFTW_COMPLEX_TO_REAL}
transform has the side-effect of destroying its (halfcomplex) input.
The @code{FFTW_REAL_TO_COMPLEX} transform, however, leaves its (real)
input untouched, just as you would hope.

As an example, here is an outline of how you might use RFFTW to compute
the power spectrum of a real array (i.e. the squares of the absolute
values of the DFT amplitudes):
@cindex power spectrum

@example
#include <rfftw.h>
...
@{
     fftw_real in[N], out[N], power_spectrum[N/2+1];
     rfftw_plan p;
     int k;
     ...
     p = rfftw_create_plan(N, FFTW_REAL_TO_COMPLEX, FFTW_ESTIMATE);
     ...
     rfftw_one(p, in, out);
     power_spectrum[0] = out[0]*out[0];  /* DC component */
     for (k = 1; k < (N+1)/2; ++k)  /* (k < N/2 rounded up) */
          power_spectrum[k] = out[k]*out[k] + out[N-k]*out[N-k];
     if (N % 2 == 0) /* N is even */
          power_spectrum[N/2] = out[N/2]*out[N/2];  /* Nyquist freq. */
     ...
     rfftw_destroy_plan(p);
@}
@end example

Programs using RFFTW should link with @code{-lrfftw -lfftw -lm} on Unix,
or with the FFTW, RFFTW, and math libraries in general.
@cindex linking on Unix

@node Real Multi-dimensional Transforms Tutorial, Multi-dimensional Array Format, Real One-dimensional Transforms Tutorial, Tutorial
@section Real Multi-dimensional Transforms Tutorial
@cindex real multi-dimensional transform

FFTW includes multi-dimensional transforms for real data of any rank.
As with the one-dimensional real transforms, they save roughly a factor
of two in time and storage over complex transforms of the same size.
Also as in one dimension, these gains come at the expense of some
increase in complexity---the output format is different from the
one-dimensional RFFTW (and is more similar to that of the complex FFTW)
and the inverse (complex to real) transforms have the side-effect of
overwriting their input data.  

To use the real multi-dimensional transforms, you first @code{#include
<rfftw.h>} and then create a plan for the size and direction of
transform that you are interested in:

@example
rfftwnd_plan rfftwnd_create_plan(int rank, const int *n,
                                 fftw_direction dir, int flags);
@end example
@tindex rfftwnd_plan
@findex rfftwnd_create_plan

The first two parameters describe the size of the real data (not the
halfcomplex data, which will have different dimensions).  The last two
parameters are the same as those for @code{rfftw_create_plan}.  Just as
for fftwnd, there are two alternate versions of this routine,
@code{rfftw2d_create_plan} and @code{rfftw3d_create_plan}, that are
sometimes more convenient for two- and three-dimensional transforms.
@findex rfftw2d_create_plan
@findex rfftw3d_create_plan
Also as in fftwnd, rfftwnd supports true in-place transforms, specified
by including @code{FFTW_IN_PLACE} in the flags.

Once created, a plan can be used for any number of transforms, and is
deallocated by calling @code{rfftwnd_destroy_plan(plan)}.

Given a plan, the transform is computed by calling one of the following
two routines:

@example
void rfftwnd_one_real_to_complex(rfftwnd_plan plan,
                                 fftw_real *in, fftw_complex *out);
void rfftwnd_one_complex_to_real(rfftwnd_plan plan,
                                 fftw_complex *in, fftw_real *out);
@end example
@findex rfftwnd_one_real_to_complex
@findex rfftwnd_one_complex_to_real

As is clear from their names and parameter types, the former function is
for @code{FFTW_REAL_TO_COMPLEX} transforms and the latter is for
@code{FFTW_COMPLEX_TO_REAL} transforms.  (We could have used only a
single routine, since the direction of the transform is encoded in the
plan, but we wanted to correctly express the datatypes of the
parameters.)  The latter routine, as we discuss elsewhere, has the
side-effect of overwriting its input (except when the rank of the array
is one).  In both cases, the @code{out} parameter is ignored for
in-place transforms.

The format of the complex arrays deserves careful attention.
@cindex rfftwnd array format
Suppose that the real data has dimensions
@tex
$n_1 \times n_2 \times \cdots \times n_d$
@end tex
@ifinfo
n1 x n2 x ... x nd
@end ifinfo
@ifhtml
n<sub>1</sub> x n<sub>2</sub> x ... x n<sub>d</sub>
@end ifhtml
(in row-major order).  Then, after a real-to-complex transform, the
output is an
@tex
$n_1 \times n_2 \times \cdots \times (n_d/2+1)$
@end tex
@ifinfo
n1 x n2 x ... x (nd/2+1)
@end ifinfo
@ifhtml
n<sub>1</sub> x n<sub>2</sub> x ... x (n<sub>d</sub>/2+1)
@end ifhtml
array of @code{fftw_complex} values in row-major order, corresponding to
slightly over half of the output of the corresponding complex transform.
(Note that the division is rounded down.)  The ordering of the data is
otherwise exactly the same as in the complex case.  (In principle, the
output could be exactly half the size of the complex transform output,
but in more than one dimension this requires too complicated a format to
be practical.)  Note that, unlike the one-dimensional RFFTW, the real
and imaginary parts of the DFT amplitudes are here stored together in
the natural way.

Since the complex data is slightly larger than the real data, some
complications arise for in-place transforms.  In this case, the final
dimension of the real data must be padded with extra values to
accommodate the size of the complex data---two extra if the last
dimension is even and one if it is odd.
@cindex padding
That is, the last dimension of the real data must physically contain
@tex
$2 (n_d/2+1)$
@end tex
@ifinfo
2 * (nd/2+1)
@end ifinfo
@ifhtml
2 * (n<sub>d</sub>/2+1)
@end ifhtml
@code{fftw_real} values (exactly enough to hold the complex data).
This physical array size does not, however, change the @emph{logical}
array size---only
@tex
$n_d$
@end tex
@ifinfo
nd
@end ifinfo
@ifhtml
n<sub>d</sub>
@end ifhtml
values are actually stored in the last dimension, and
@tex
$n_d$
@end tex
@ifinfo
nd
@end ifinfo
@ifhtml
n<sub>d</sub>
@end ifhtml
is the last dimension passed to @code{rfftwnd_create_plan}.

For example, consider the transform of a two-dimensional real array of
size @code{nx} by @code{ny}.  The output of the @code{rfftwnd} transform
is a two-dimensional complex array of size @code{nx} by @code{ny/2+1},
where the @code{y} dimension has been cut nearly in half because of
redundancies in the output.  Because @code{fftw_complex} is twice the
size of @code{fftw_real}, the output array is slightly bigger than the
input array.  Thus, if we want to compute the transform in place, we
must @emph{pad} the input array so that it is of size @code{nx} by
@code{2*(ny/2+1)}.  If @code{ny} is even, then there are two padding
elements at the end of each row (which need not be initialized, as they
are only used for output).
@ifhtml
The following illustration depicts the input and output arrays just
described, for both the out-of-place and in-place transforms (with the
arrows indicating consecutive memory locations):

<p align=center><img src="rfftwnd.gif" width=389 height=583>
@end ifhtml

@tex
Figure 1 depicts the input and output arrays just
described, for both the out-of-place and in-place transforms (with the
arrows indicating consecutive memory locations).

{
\pageinsert
\vfill
\vskip405pt
\hskip40pt
\special{psfile="rfftwnd.eps" 
}
\vskip 24pt
Figure 1: Illustration of the data layout for real to complex
transforms.  
\vfill
\endinsert}
@end tex

The RFFTWND transforms are unnormalized, so a forward followed by a
backward transform will result in the original data scaled by the number
of real data elements---that is, the product of the (logical) dimensions
of the real data.
@cindex normalization

Below, we illustrate the use of RFFTWND by showing how you might use it
to compute the (cyclic) convolution of two-dimensional real arrays
@code{a} and @code{b} (using the identity that a convolution corresponds
to a pointwise product of the Fourier transforms).  For variety,
in-place transforms are used for the forward FFTs and an out-of-place
transform is used for the inverse transform.
@cindex convolution
@cindex cyclic convolution

@example
#include <rfftw.h>
...
@{
     fftw_real a[M][2*(N/2+1)], b[M][2*(N/2+1)], c[M][N];
     fftw_complex *A, *B, C[M][N/2+1];
     rfftwnd_plan p, pinv;
     fftw_real scale = 1.0 / (M * N);
     int i, j;
     ...
     p    = rfftw2d_create_plan(M, N, FFTW_REAL_TO_COMPLEX,
                                FFTW_ESTIMATE | FFTW_IN_PLACE);
     pinv = rfftw2d_create_plan(M, N, FFTW_COMPLEX_TO_REAL,
                                FFTW_ESTIMATE);

     /* aliases for accessing complex transform outputs: */
     A = (fftw_complex*) &a[0][0];
     B = (fftw_complex*) &b[0][0];
     ...
     for (i = 0; i < M; ++i)
          for (j = 0; j < N; ++j) @{
               a[i][j] = ... ;
               b[i][j] = ... ;
          @}
     ...
     rfftwnd_one_real_to_complex(p, &a[0][0], NULL);
     rfftwnd_one_real_to_complex(p, &b[0][0], NULL);

     for (i = 0; i < M; ++i)
          for (j = 0; j < N/2+1; ++j) @{
               int ij = i*(N/2+1) + j;
               C[i][j].re = (A[ij].re * B[ij].re
                             - A[ij].im * B[ij].im) * scale;
               C[i][j].im = (A[ij].re * B[ij].im
                             + A[ij].im * B[ij].re) * scale;
          @}

     /* inverse transform to get c, the convolution of a and b;
        this has the side effect of overwriting C */
     rfftwnd_one_complex_to_real(pinv, &C[0][0], &c[0][0]);
     ...
     rfftwnd_destroy_plan(p);
     rfftwnd_destroy_plan(pinv);
@}
@end example

We access the complex outputs of the in-place transforms by casting
each real array to a @code{fftw_complex} pointer.  Because this is a
``flat'' pointer, we have to compute the row-major index @code{ij}
explicitly in the convolution product loop.
@cindex row-major
In order to normalize the convolution, we must multiply by a scale
factor---we can do so either before or after the inverse transform, and
choose the former because it obviates the necessity of an additional
loop.
@cindex normalization
Notice the limits of the loops and the dimensions of the various arrays.

As with the one-dimensional RFFTW, an out-of-place
@code{FFTW_COMPLEX_TO_REAL} transform has the side-effect of overwriting
its input array.  (The real-to-complex transform, on the other hand,
leaves its input array untouched.)  If you use RFFTWND for a rank-one
transform, however, this side-effect does not occur.  Because of this
fact (and the simpler output format), users may find the RFFTWND
interface more convenient than RFFTW for one-dimensional transforms.
However, RFFTWND in one dimension is slightly slower than RFFTW because
RFFTWND uses an extra buffer array internally.

@c ------------------------------------------------------------
@node Multi-dimensional Array Format, Words of Wisdom, Real Multi-dimensional Transforms Tutorial, Tutorial
@section Multi-dimensional Array Format

This section describes the format in which multi-dimensional arrays are
stored.  We felt that a detailed discussion of this topic was necessary,
since it is often a source of confusion among users and several
different formats are common.  Although the comments below refer to
@code{fftwnd}, they are also applicable to the @code{rfftwnd} routines.

@menu
* Row-major Format::            
* Column-major Format::         
* Static Arrays in C::          
* Dynamic Arrays in C::         
* Dynamic Arrays in C-The Wrong Way::  
@end menu

@node Row-major Format, Column-major Format, Multi-dimensional Array Format, Multi-dimensional Array Format
@subsection Row-major Format
@cindex row-major

The multi-dimensional arrays passed to @code{fftwnd} are expected to be
stored as a single contiguous block in @dfn{row-major} order (sometimes
called ``C order'').  Basically, this means that as you step through
adjacent memory locations, the first dimension's index varies most
slowly and the last dimension's index varies most quickly.

To be more explicit, let us consider an array of rank @math{d} whose
dimensions are
@tex
$n_1 \times n_2 \times n_3 \times \cdots \times n_d$.
@end tex
@ifinfo
n1 x n2 x n3 x ... x nd.
@end ifinfo
@ifhtml
n<sub>1</sub> x n<sub>2</sub> x n<sub>3</sub> x ... x n<sub>d</sub>.
@end ifhtml
Now, we specify a location in the array by a sequence of (zero-based) indices,
one for each dimension:
@tex
$(i_1, i_2, i_3, \ldots, i_d)$.
@end tex
@ifinfo
(i1, i2, ..., id).
@end ifinfo
@ifhtml
(i<sub>1</sub>, i<sub>2</sub>, i<sub>3</sub>,..., i<sub>d</sub>).
@end ifhtml
If the array is stored in row-major
order, then this element is located at the position
@tex
$i_d + n_d (i_{d-1} + n_{d-1} (\ldots + n_2 i_1))$.
@end tex
@ifinfo
id + nd * (id-1 + nd-1 * (... + n2 * i1)).
@end ifinfo
@ifhtml
i<sub>d</sub> + n<sub>d</sub> * (i<sub>d-1</sub> + n<sub>d-1</sub> * (... + n<sub>2</sub> * i<sub>1</sub>)).
@end ifhtml

Note that each element of the array must be of type @code{fftw_complex};
i.e. a (real, imaginary) pair of (double-precision) numbers. Note also
that, in @code{fftwnd}, the expression above is multiplied by the stride
to get the actual array index---this is useful in situations where each
element of the multi-dimensional array is actually a data structure or
another array, and you just want to transform a single field. In most
cases, however, you use a stride of 1.
@cindex stride

@node Column-major Format, Static Arrays in C, Row-major Format, Multi-dimensional Array Format
@subsection Column-major Format
@cindex column-major

Readers from the Fortran world are used to arrays stored in
@dfn{column-major} order (sometimes called ``Fortran order'').  This is
essentially the exact opposite of row-major order in that, here, the
@emph{first} dimension's index varies most quickly.

If you have an array stored in column-major order and wish to transform
it using @code{fftwnd}, it is quite easy to do.  When creating the plan,
simply pass the dimensions of the array to @code{fftwnd_create_plan} in
@emph{reverse order}.  For example, if your array is a rank three
@code{N x M x L} matrix in column-major order, you should pass the
dimensions of the array as if it were an @code{L x M x N} matrix (which
it is, from the perspective of @code{fftwnd}).  This is done for you
automatically by the FFTW Fortran wrapper routines (@pxref{Calling FFTW
from Fortran}).
@cindex Fortran-callable wrappers

@node Static Arrays in C, Dynamic Arrays in C, Column-major Format, Multi-dimensional Array Format
@subsection Static Arrays in C
@cindex C multi-dimensional arrays

Multi-dimensional arrays declared statically (that is, at compile time,
not necessarily with the @code{static} keyword) in C are @emph{already}
in row-major order.  You don't have to do anything special to transform
them.  (@xref{Complex Multi-dimensional Transforms Tutorial}, for an
example of this sort of code.)

@node Dynamic Arrays in C, Dynamic Arrays in C-The Wrong Way, Static Arrays in C, Multi-dimensional Array Format
@subsection Dynamic Arrays in C

Often, especially for large arrays, it is desirable to allocate the
arrays dynamically, at runtime.  This isn't too hard to do, although it
is not as straightforward for multi-dimensional arrays as it is for
one-dimensional arrays.

Creating the array is simple: using a dynamic-allocation routine like
@code{malloc}, allocate an array big enough to store N @code{fftw_complex}
values, where N is the product of the sizes of the array dimensions
(i.e. the total number of complex values in the array).  For example,
here is code to allocate a 5x12x27 rank 3 array:
@ffindex malloc

@example
fftw_complex *an_array;

an_array = (fftw_complex *) malloc(5 * 12 * 27 * sizeof(fftw_complex));
@end example

Accessing the array elements, however, is more tricky---you can't simply
use multiple applications of the @samp{[]} operator like you could for
static arrays.  Instead, you have to explicitly compute the offset into
the array using the formula given earlier for row-major arrays.  For
example, to reference the @math{(i,j,k)}-th element of the array
allocated above, you would use the expression @code{an_array[k + 27 * (j
+ 12 * i)]}.

This pain can be alleviated somewhat by defining appropriate macros, or,
in C++, creating a class and overloading the @samp{()} operator.

@node Dynamic Arrays in C-The Wrong Way,  , Dynamic Arrays in C, Multi-dimensional Array Format
@subsection Dynamic Arrays in C---The Wrong Way

A different method for allocating multi-dimensional arrays in C is often
suggested that is incompatible with @code{fftwnd}: @emph{using it will
cause FFTW to die a painful death}.  We discuss the technique here,
however, because it is so commonly known and used.  This method is to
create arrays of pointers of arrays of pointers of @dots{}etcetera.  For
example, the analogue in this method to the example above is:

@example
int i,j;
fftw_complex ***a_bad_array;  /* another way to make a 5x12x27 array */

a_bad_array = (fftw_complex ***) malloc(5 * sizeof(fftw_complex **));
for (i = 0; i < 5; ++i) @{
     a_bad_array[i] = 
        (fftw_complex **) malloc(12 * sizeof(fftw_complex *));
     for (j = 0; j < 12; ++j)
          a_bad_array[i][j] =
                (fftw_complex *) malloc(27 * sizeof(fftw_complex));
@}
@end example

As you can see, this sort of array is inconvenient to allocate (and
deallocate).  On the other hand, it has the advantage that the
@math{(i,j,k)}-th element can be referenced simply by
@code{a_bad_array[i][j][k]}.

If you like this technique and want to maximize convenience in accessing
the array, but still want to pass the array to FFTW, you can use a
hybrid method.  Allocate the array as one contiguous block, but also
declare an array of arrays of pointers that point to appropriate places
in the block.  That sort of trick is beyond the scope of this
documentation; for more information on multi-dimensional arrays in C,
see the @code{comp.lang.c}
@uref{http://www.eskimo.com/~scs/C-faq/s6.html, FAQ}.

@c ------------------------------------------------------------
@node Words of Wisdom,  , Multi-dimensional Array Format, Tutorial
@section Words of Wisdom
@cindex wisdom
@cindex saving plans to disk

FFTW implements a method for saving plans to disk and restoring them.
In fact, what FFTW does is more general than just saving and loading
plans.  The mechanism is called @dfn{@code{wisdom}}.  Here, we describe
this feature at a high level. @xref{FFTW Reference}, for a less casual
(but more complete) discussion of how to use @code{wisdom} in FFTW.

Plans created with the @code{FFTW_MEASURE} option produce near-optimal
FFT performance, but it can take a long time to compute a plan because
FFTW must actually measure the runtime of many possible plans and select
the best one.  This is designed for the situations where so many
transforms of the same size must be computed that the start-up time is
irrelevant.  For short initialization times but slightly slower
transforms, we have provided @code{FFTW_ESTIMATE}.  The @code{wisdom}
mechanism is a way to get the best of both worlds.  There are, however,
certain caveats that the user must be aware of in using @code{wisdom}.
For this reason, @code{wisdom} is an optional feature which is not
enabled by default.

At its simplest, @code{wisdom} provides a way of saving plans to disk so
that they can be reused in other program runs.  You create a plan with
the flags @code{FFTW_MEASURE} and @code{FFTW_USE_WISDOM}, and then save
the @code{wisdom} using @code{fftw_export_wisdom}:
@ctindex FFTW_USE_WISDOM

@example
     plan = fftw_create_plan(..., ... | FFTW_MEASURE | FFTW_USE_WISDOM);
     fftw_export_wisdom(...);
@end example
@findex fftw_export_wisdom

The next time you run the program, you can restore the @code{wisdom}
with @code{fftw_import_wisdom}, and then recreate the plan using the
same flags as before.  This time, however, the same optimal plan will be
created very quickly without measurements. (FFTW still needs some time
to compute trigonometric tables, however.)  The basic outline is:

@example
     fftw_import_wisdom(...);
     plan = fftw_create_plan(..., ... | FFTW_USE_WISDOM);
@end example
@findex fftw_import_wisdom

Wisdom is more than mere rote memorization, however.  FFTW's
@code{wisdom} encompasses all of the knowledge and measurements that
were used to create the plan for a given size.  Therefore, existing
@code{wisdom} is also applied to the creation of other plans of
different sizes.

Whenever a plan is created with the @code{FFTW_MEASURE} and
@code{FFTW_USE_WISDOM} flags, @code{wisdom} is generated.  Thereafter,
plans for any transform with a similar factorization will be computed
more quickly, so long as they use the @code{FFTW_USE_WISDOM} flag.  In
fact, for transforms with the same factors and of equal or lesser size,
no measurements at all need to be made and an optimal plan can be
created with negligible delay!

For example, suppose that you create a plan for
@tex
$N = 2^{16}$.
@end tex
@ifinfo
N = 2^16.
@end ifinfo
@ifhtml
N&nbsp;=&nbsp;2<sup>16</sup>.
@end ifhtml
Then, for any equal or smaller power of two, FFTW can create a
plan (with the same direction and flags) quickly, using the
precomputed @code{wisdom}. Even for larger powers of two, or sizes that
are a power of two times some other prime factors, plans will be
computed more quickly than they would otherwise (although some
measurements still have to be made).

The @code{wisdom} is cumulative, and is stored in a global, private data
structure managed internally by FFTW.  The storage space required is
minimal, proportional to the logarithm of the sizes the @code{wisdom} was
generated from.  The @code{wisdom} can be forgotten (and its associated
memory freed) by a call to @code{fftw_forget_wisdom()}; otherwise, it is
remembered until the program terminates.  It can also be exported to a
file, a string, or any other medium using @code{fftw_export_wisdom} and
restored during a subsequent execution of the program (or a different
program) using @code{fftw_import_wisdom} (these functions are described
below).

Because @code{wisdom} is incorporated into FFTW at a very low level, the
same @code{wisdom} can be used for one-dimensional transforms,
multi-dimensional transforms, and even the parallel extensions to FFTW.
Just include @code{FFTW_USE_WISDOM} in the flags for whatever plans you
create (i.e., always plan wisely).

Plans created with the @code{FFTW_ESTIMATE} plan can use @code{wisdom},
but cannot generate it;  only @code{FFTW_MEASURE} plans actually produce
@code{wisdom}.  Also, plans can only use @code{wisdom} generated from
plans created with the same direction and flags.  For example, a size
@code{42} @code{FFTW_BACKWARD} transform will not use @code{wisdom}
produced by a size @code{42} @code{FFTW_FORWARD} transform.  The only
exception to this rule is that @code{FFTW_ESTIMATE} plans can use
@code{wisdom} from @code{FFTW_MEASURE} plans.

@menu
* Caveats in Using Wisdom::     What you should worry about in using wisdom
* Importing and Exporting Wisdom::  I/O of wisdom to disk and other media
@end menu

@node Caveats in Using Wisdom, Importing and Exporting Wisdom, Words of Wisdom, Words of Wisdom
@subsection Caveats in Using Wisdom
@cindex wisdom, problems with

@quotation
@ifhtml
<i>
@end ifhtml
For in much wisdom is much grief, and he that increaseth knowledge
increaseth sorrow.
@ifhtml
</i>
@end ifhtml
[Ecclesiastes 1:18]
@cindex Ecclesiastes
@end quotation

There are pitfalls to using @code{wisdom}, in that it can negate FFTW's
ability to adapt to changing hardware and other conditions. For example,
it would be perfectly possible to export @code{wisdom} from a program
running on one processor and import it into a program running on another
processor.  Doing so, however, would mean that the second program would
use plans optimized for the first processor, instead of the one it is
running on.

It should be safe to reuse @code{wisdom} as long as the hardware and
program binaries remain unchanged. (Actually, the optimal plan may
change even between runs of the same binary on identical hardware, due
to differences in the virtual memory environment, etcetera.  Users
seriously interested in performance should worry about this problem,
too.)  It is likely that, if the same @code{wisdom} is used for two
different program binaries, even running on the same machine, the plans
may be sub-optimal because of differing code alignments.  It is
therefore wise to recreate @code{wisdom} every time an application is
recompiled.  The more the underlying hardware and software changes
between the creation of @code{wisdom} and its use, the greater grows the
risk of sub-optimal plans.

@node Importing and Exporting Wisdom,  , Caveats in Using Wisdom, Words of Wisdom
@subsection Importing and Exporting Wisdom
@cindex wisdom, import and export

@example
void fftw_export_wisdom_to_file(FILE *output_file);
fftw_status fftw_import_wisdom_from_file(FILE *input_file);
@end example
@findex fftw_export_wisdom_to_file
@findex fftw_import_wisdom_from_file

@code{fftw_export_wisdom_to_file} writes the @code{wisdom} to
@code{output_file}, which must be a file open for
writing. @code{fftw_import_wisdom_from_file} reads the @code{wisdom}
from @code{input_file}, which must be a file open for reading, and
returns @code{FFTW_SUCCESS} if successful and @code{FFTW_FAILURE}
otherwise. In both cases, the file is left open and must be closed by
the caller.  It is perfectly fine if other data lie before or after the
@code{wisdom} in the file, as long as the file is positioned at the
beginning of the @code{wisdom} data before import.

@example
char *fftw_export_wisdom_to_string(void);
fftw_status fftw_import_wisdom_from_string(const char *input_string)
@end example
@findex fftw_export_wisdom_to_string
@findex fftw_import_wisdom_from_string

@code{fftw_export_wisdom_to_string} allocates a string, exports the
@code{wisdom} to it in @code{NULL}-terminated format, and returns a
pointer to the string.  If there is an error in allocating or writing
the data, it returns @code{NULL}.  The caller is responsible for
deallocating the string (with @code{fftw_free}) when she is done with
it. @code{fftw_import_wisdom_from_string} imports the @code{wisdom} from
@code{input_string}, returning @code{FFTW_SUCCESS} if successful and
@code{FFTW_FAILURE} otherwise.

Exporting @code{wisdom} does not affect the store of @code{wisdom}. Imported
@code{wisdom} supplements the current store rather than replacing it
(except when there is conflicting @code{wisdom}, in which case the older
@code{wisdom} is discarded). The format of the exported @code{wisdom} is
``nerd-readable'' LISP-like ASCII text; we will not document it here
except to note that it is insensitive to white space (interested users
can contact us for more details).
@cindex LISP
@cindex nerd-readable text

@xref{FFTW Reference}, for more information, and for a description of
how you can implement @code{wisdom} import/export for other media
besides files and strings.

The following is a brief example in which the @code{wisdom} is read from
a file, a plan is created (possibly generating more @code{wisdom}), and
then the @code{wisdom} is exported to a string and printed to
@code{stdout}.

@example
@{
     fftw_plan plan;
     char *wisdom_string;
     FILE *input_file;

     /* open file to read wisdom from */
     input_file = fopen("sample.wisdom", "r");
     if (FFTW_FAILURE == fftw_import_wisdom_from_file(input_file))
          printf("Error reading wisdom!\n");
     fclose(input_file); /* be sure to close the file! */

     /* create a plan for N=64, possibly creating and/or using wisdom */
     plan = fftw_create_plan(64,FFTW_FORWARD,
                             FFTW_MEASURE | FFTW_USE_WISDOM);

     /* ... do some computations with the plan ... */

     /* always destroy plans when you are done */
     fftw_destroy_plan(plan);

     /* write the wisdom to a string */
     wisdom_string = fftw_export_wisdom_to_string();
     if (wisdom_string != NULL) @{
          printf("Accumulated wisdom: %s\n",wisdom_string);

          /* Just for fun, destroy and restore the wisdom */
          fftw_forget_wisdom(); /* all gone! */
          fftw_import_wisdom_from_string(wisdom_string);
          /* wisdom is back! */

          fftw_free(wisdom_string); /* deallocate it since we're done */
     @}
@}
@end example

@c ************************************************************
@node FFTW Reference, Parallel FFTW, Tutorial, Top
@chapter FFTW Reference

This chapter provides a complete reference for all sequential (i.e.,
one-processor) FFTW functions.  We first define the data types upon
which FFTW operates, that is, real, complex, and ``halfcomplex'' numbers
(@pxref{Data Types}).  Then, in four sections, we explain the FFTW
program interface for complex one-dimensional transforms
(@pxref{One-dimensional Transforms Reference}), complex
multi-dimensional transforms (@pxref{Multi-dimensional Transforms
Reference}), and real one-dimensional transforms (@pxref{Real
One-dimensional Transforms Reference}), real multi-dimensional
transforms (@pxref{Real Multi-dimensional Transforms Reference}).
@ref{Wisdom Reference} describes the @code{wisdom} mechanism for
exporting and importing plans.  Finally, @ref{Memory Allocator
Reference} describes how to change FFTW's default memory allocator.
For parallel transforms, @xref{Parallel FFTW}.

@menu
* Data Types::                  real, complex, and halfcomplex numbers
* One-dimensional Transforms Reference::  
* Multi-dimensional Transforms Reference::  
* Real One-dimensional Transforms Reference::  
* Real Multi-dimensional Transforms Reference::  
* Wisdom Reference::            
* Memory Allocator Reference::  
* Thread safety::               
@end menu

@c -------------------------------------------------------
@node Data Types, One-dimensional Transforms Reference, FFTW Reference, FFTW Reference
@section Data Types
@cindex real number
@cindex complex number
@cindex halfcomplex array

The routines in the FFTW package use three main kinds of data types.
@dfn{Real} and @dfn{complex} numbers should be already known to the
reader.  We also use the term @dfn{halfcomplex} to describe complex
arrays in a special packed format used by the one-dimensional real
transforms (taking advantage of the @dfn{hermitian} symmetry that arises
in those cases).

By including @code{<fftw.h>} or @code{<rfftw.h>}, you will have access
to the following definitions:

@example
typedef double fftw_real;

typedef struct @{
     fftw_real re, im;
@} fftw_complex;

#define c_re(c)  ((c).re)
#define c_im(c)  ((c).im)
@end example
@tindex fftw_real
@tindex fftw_complex

All FFTW operations are performed on the @code{fftw_real} and
@code{fftw_complex} data types.  For @code{fftw_complex} numbers, the
two macros @code{c_re} and @code{c_im} retrieve, respectively, the real
and imaginary parts of the number.

A @dfn{real array} is an array of real numbers.  A @dfn{complex array}
is an array of complex numbers.  A one-dimensional array @math{X} of
@math{n} complex numbers is @dfn{hermitian} if the following property
holds:
@tex
for all $0 \leq i < n$, we have $X_i = X^{*}_{n-i}$, where
$x^*$ denotes the complex conjugate of $x$.
@end tex
@ifinfo
for all @math{0 <= i < n}, we have @math{X[i] = conj(X[n-i])}.
@end ifinfo
@ifhtml
for all 0 &lt;= i &lt; n, we have X<sub>i</sub> = conj(X<sub>n-i</sub>)}.
@end ifhtml
Hermitian arrays are relevant to FFTW because the Fourier transform of a
real array is hermitian.

Because of its symmetry, a hermitian array can be stored in half the
space of a complex array of the same size.  FFTW's one-dimensional real
transforms store hermitian arrays as @dfn{halfcomplex} arrays.  A
halfcomplex array of size @math{n} is
@cindex hermitian array
a one-dimensional array of @math{n} @code{fftw_real} numbers.  A
hermitian array @math{X} in stored into a halfcomplex array @math{Y} as
follows.
@tex
For all integers $i$ such that $0 \leq i \leq n / 2$, we have $Y_i :=
\hbox{Re}(X_i)$.  For all integers $i$ such that $0 < i < n / 2$,
we have $Y_{n - i} := \hbox{Im}(X_i)$.
@end tex
@ifinfo
For all integers @math{i} such that @math{0 <= i <= n / 2}, we have
@math{Y[i] = Re(X[i])}.  For all integers @math{i} such that @math{0 <
i < n / 2}, we have @math{Y[n-i] = Im(X[i])}.
@end ifinfo
@ifhtml
For all integers i such that 0 &lt;= i &lt;= n / 2, we have
Y<sub>i</sub> = Re(X<sub>i</sub>).  For all integers i such that 0
&lt; i &lt; n / 2, we have Y<sub>n-i</sub> = Im(X<sub>i</sub>).
@end ifhtml

We now illustrate halfcomplex storage for @math{n = 4} and @math{n = 5},
since the scheme depends on the parity of @math{n}.  Let @math{n = 4}.
In this case, we have
@tex
$Y_0 := \hbox{Re}(X_0)$, $Y_1 := \hbox{Re}(X_1)$,
$Y_2 := \hbox{Re}(X_2)$, and $Y_3 := \hbox{Im}(X_1)$.
@end tex
@ifinfo
@math{Y[0] = Re(X[0])}, @math{Y[1] = Re(X[1])},
@math{Y[2] = Re(X[2])}, and  @math{Y[3] = Im(X[1])}.
@end ifinfo
@ifhtml
Y<sub>0</sub> = Re(X<sub>0</sub>), Y<sub>1</sub> = Re(X<sub>1</sub>),
Y<sub>2</sub> = Re(X<sub>2</sub>), and  Y<sub>3</sub> = Im(X<sub>1</sub>).
@end ifhtml
Let now @math{n = 5}.  In this case, we have
@tex
$Y_0 := \hbox{Re}(X_0)$, $Y_1 := \hbox{Re}(X_1)$,
$Y_2 := \hbox{Re}(X_2)$, $Y_3 := \hbox{Im}(X_2)$, and 
$Y_4 := \hbox{Im}(X_1)$.
@end tex
@ifinfo
@math{Y[0] = Re(X[0])}, @math{Y[1] = Re(X[1])},
@math{Y[2] = Re(X[2])}, @math{Y[3] = Im(X[2])}, and
@math{Y[4] = Im(X[1])}.
@end ifinfo
@ifhtml
Y<sub>0</sub> = Re(X<sub>0</sub>), Y<sub>1</sub> = Re(X<sub>1</sub>),
Y<sub>2</sub> = Re(X<sub>2</sub>), Y<sub>3</sub> = Im(X<sub>2</sub>),
and Y<sub>4</sub> = Im(X<sub>1</sub>).
@end ifhtml

@cindex floating-point precision
By default, the type @code{fftw_real} equals the C type @code{double}.
To work in single precision rather than double precision, @code{#define}
the symbol @code{FFTW_ENABLE_FLOAT} in @code{fftw.h} and then recompile
the library.  On Unix systems, you can instead use @code{configure
--enable-float} at installation time (@pxref{Installation and
Customization}).
@fpindex configure
@ctindex FFTW_ENABLE_FLOAT

In version 1 of FFTW, the data types were called @code{FFTW_REAL} and
@code{FFTW_COMPLEX}.  We changed the capitalization for consistency with
the rest of FFTW's conventions.  The old names are still supported, but
their use is deprecated.
@tindex FFTW_REAL
@tindex FFTW_COMPLEX

@c -------------------------------------------------------
@node One-dimensional Transforms Reference, Multi-dimensional Transforms Reference, Data Types, FFTW Reference
@section One-dimensional Transforms Reference

The one-dimensional complex routines are generally prefixed with
@code{fftw_}.  Programs using FFTW should be linked with @code{-lfftw
-lm} on Unix systems, or with the FFTW and standard math libraries in
general.

@menu
* fftw_create_plan::            Plan Creation
* Discussion on Specific Plans::  
* fftw::                        Plan Execution
* fftw_destroy_plan::           Plan Destruction
* What FFTW Really Computes::   Definition of the DFT.
@end menu

@node    fftw_create_plan, Discussion on Specific Plans, One-dimensional Transforms Reference, One-dimensional Transforms Reference
@subsection Plan Creation for One-dimensional Transforms

@example
#include <fftw.h>

fftw_plan fftw_create_plan(int n, fftw_direction dir,
                           int flags);

fftw_plan fftw_create_plan_specific(int n, fftw_direction dir,
                                    int flags,
                                    fftw_complex *in, int istride,
                                    fftw_complex *out, int ostride);
@end example
@tindex fftw_plan
@tindex fftw_direction
@findex fftw_create_plan
@findex fftw_create_plan_specific

The function @code{fftw_create_plan} creates a plan, which is
a data structure containing all the information that @code{fftw}
needs in order to compute the 1D Fourier transform. You can
create as many plans as you need, but only one plan for a given
array size is required (a plan can be reused many times).

@code{fftw_create_plan} returns a valid plan, or @code{NULL}
if, for some reason, the plan can't be created.  In the
default installation, this cannot happen, but it is possible
to configure FFTW in such a way that some input sizes are
forbidden, and FFTW cannot create a plan.

The @code{fftw_create_plan_specific} variant takes as additional
arguments specific input/output arrays and their strides.  For the last
four arguments, you should pass the arrays and strides that you will
eventually be passing to @code{fftw}.  The resulting plans will be
optimized for those arrays and strides, although they may be used on
other arrays as well.  Note: the contents of the in and out arrays are
@emph{destroyed} by the specific planner (the initial contents are
ignored, so the arrays need not have been initialized).

@subsubheading Arguments
@itemize @bullet
@item
@code{n} is the size of the transform.  It can be
 any positive integer.
 
@itemize @minus
@item
FFTW is best at handling sizes of the form
@ifinfo
@math{2^a 3^b 5^c 7^d 11^e 13^f},
@end ifinfo
@tex
$2^a 3^b 5^c 7^d 11^e 13^f$,
@end tex
@ifhtml
2<SUP>a</SUP> 3<SUP>b</SUP> 5<SUP>c</SUP> 7<SUP>d</SUP>
        11<SUP>e</SUP> 13<SUP>f</SUP>,
@end ifhtml
where @math{e+f} is either @math{0} or
@math{1}, and the other exponents are arbitrary.  Other sizes are
computed by means of a slow, general-purpose routine (which nevertheless
retains 
@tex
$O(n \log n)$
@end tex
@ifinfo
O(n lg n)
@end ifinfo
@ifhtml
O(n lg n)
@end ifhtml
performance, even for prime sizes).  (It is
possible to customize FFTW for different array sizes.
@xref{Installation and Customization}, for more information.)  Transforms
whose sizes are powers of @math{2} are especially fast.
@end itemize

@item
@code{dir} is the sign of the exponent in the formula that
defines the Fourier transform.  It can be @math{-1} or @math{+1}.
The aliases @code{FFTW_FORWARD} and @code{FFTW_BACKWARD}
are provided, where @code{FFTW_FORWARD} stands for @math{-1}.

@item
@cindex flags
@code{flags} is a boolean OR (@samp{|}) of zero or more of the following:
@itemize @minus
@item
@code{FFTW_MEASURE}: this flag tells FFTW to find the optimal plan by
actually @emph{computing} several FFTs and measuring their
execution time.  Depending on the installation, this can take some
time. @footnote{The basic problem is the resolution of the clock:
FFTW needs to run for a certain time for the clock to be reliable.}

@item
@code{FFTW_ESTIMATE}: do not run any FFT and provide a ``reasonable''
plan (for a RISC processor with many registers).  If neither
@code{FFTW_ESTIMATE} nor @code{FFTW_MEASURE} is provided, the default is
@code{FFTW_ESTIMATE}.

@item
@code{FFTW_OUT_OF_PLACE}: produce a plan assuming that the input and
output arrays will be distinct (this is the default).
@ctindex FFTW_OUT_OF_PLACE

@item
@cindex in-place transform
@code{FFTW_IN_PLACE}: produce a plan assuming that you want the output
in the input array.  The algorithm used is not necessarily in place:
FFTW is able to compute true in-place transforms only for small values
of @code{n}.  If FFTW is not able to compute the transform in-place, it
will allocate a temporary array (unless you provide one yourself),
compute the transform out of place, and copy the result back.
@emph{Warning: This option changes the meaning of some parameters of
@code{fftw}} (@pxref{fftw,,Computing the One-dimensional Transform}).

The in-place option is mainly provided for people who want to write
their own in-place multi-dimensional Fourier transform, using FFTW as a
base.  For example, consider a three-dimensional @code{n * n * n}
transform.  An out-of-place algorithm will need another array (which may
be huge).  However, FFTW can compute the in-place transform along
each dimension using only a temporary array of size @code{n}.
Moreover, if FFTW happens to be able to compute the transform truly
in-place, no temporary array and no copying are needed.  As distributed,
FFTW `knows' how to compute in-place transforms of size 1, 2, 3, 4, 5, 6,
7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 32 and 64.

The default mode of operation is @code{FFTW_OUT_OF_PLACE}.

@item
@cindex wisdom
@code{FFTW_USE_WISDOM}: use any @code{wisdom} that is available to help
in the creation of the plan. (@xref{Words of Wisdom}.)
This can greatly speed the creation of plans, especially with the
@code{FFTW_MEASURE} option. @code{FFTW_ESTIMATE} plans can also take
advantage of @code{wisdom} to produce a more optimal plan (based on past
measurements) than the estimation heuristic would normally
generate. When the @code{FFTW_MEASURE} option is used, new @code{wisdom}
will also be generated if the current transform size is not completely
understood by existing @code{wisdom}.

@end itemize

@item
@code{in}, @code{out}, @code{istride}, @code{ostride} (only for
@code{fftw_create_plan_specific}): see corresponding arguments in the
description of @code{fftw}.  (@xref{fftw,,Computing the One-dimensional
Transform}.)  In particular, the @code{out} and @code{ostride}
parameters have the same special meaning for @code{FFTW_IN_PLACE}
transforms as they have for @code{fftw}.

@end itemize

@node Discussion on Specific Plans, fftw, fftw_create_plan, One-dimensional Transforms Reference
@subsection Discussion on Specific Plans
@cindex specific planner
We recommend the use of the specific planners, even in cases where you
will be transforming arrays different from those passed to the specific
planners, as they confer the following advantages:

@itemize @bullet

@item
The resulting plans will be optimized for your specific arrays and
strides.  This may or may not make a significant difference, but it
certainly doesn't hurt.  (The ordinary planner does its planning based
upon a stride-one temporary array that it allocates.)

@item
Less intermediate storage is required during the planning process.  (The
ordinary planner uses O(@code{N}) temporary storage, where @code{N} is
the maximum dimension, while it is creating the plan.)

@item
For multi-dimensional transforms, new parameters become accessible for
optimization by the planner.  (Since multi-dimensional arrays can be
very large, we don't dare to allocate one in the ordinary planner for
experimentation.  This prevents us from doing certain optimizations
that can yield dramatic improvements in some cases.)

@end itemize

On the other hand, note that @emph{the specific planner destroys the
contents of the @code{in} and @code{out} arrays}.

@node    fftw, fftw_destroy_plan, Discussion on Specific Plans, One-dimensional Transforms Reference
@subsection Computing the One-dimensional Transform

@example
#include <fftw.h>

void fftw(fftw_plan plan, int howmany,
          fftw_complex *in, int istride, int idist,
          fftw_complex *out, int ostride, int odist);

void fftw_one(fftw_plan plan, fftw_complex *in, 
          fftw_complex *out);
@end example
@findex fftw
@findex fftw_one

The function @code{fftw} computes the one-dimensional Fourier transform,
using a plan created by @code{fftw_create_plan} (@xref{fftw_create_plan,
, Plan Creation for One-dimensional Transforms}.)  The function
@code{fftw_one} provides a simplified interface for the common case of
single input array of stride 1.
@cindex stride

@subsubheading Arguments
@itemize @bullet
@item
@code{plan} is the plan created by @code{fftw_create_plan}
(@pxref{fftw_create_plan,,Plan Creation for One-dimensional Transforms}).

@item
@code{howmany} is the number of transforms @code{fftw} will compute.
It is faster to tell FFTW to compute many transforms, instead of
simply calling @code{fftw} many times.

@item
@code{in}, @code{istride} and @code{idist} describe the input array(s).
There are @code{howmany} input arrays; the first one is pointed to by
@code{in}, the second one is pointed to by @code{in + idist}, and so on,
up to @code{in + (howmany - 1) * idist}.  Each input array consists of
complex numbers (@pxref{Data Types}), which are not necessarily
contiguous in memory.  Specifically, @code{in[0]} is the first element
of the first array, @code{in[istride]} is the second element of the
first array, and so on.  In general, the @code{i}-th element of the
@code{j}-th input array will be in position @code{in[i * istride + j *
idist]}.

@item
@code{out}, @code{ostride} and @code{odist} describe the output
array(s).  The format is the same as for the input array.

@itemize @minus
@item @emph{In-place transforms}:
@cindex in-place transform
If the @code{plan} specifies an in-place transform, @code{ostride} and
@code{odist} are always ignored.  If @code{out} is @code{NULL},
@code{out} is ignored, too.  Otherwise, @code{out} is interpreted as a
pointer to an array of @code{n} complex numbers, that FFTW will use as
temporary space to perform the in-place computation.  @code{out} is used
as scratch space and its contents destroyed.  In this case, @code{out}
must be an ordinary array whose elements are contiguous in memory (no
striding).
@end itemize

@end itemize

The function @code{fftw_one} transforms a single, contiguous input array
to a contiguous output array.  By definition, the call
@example
fftw_one(plan, in, out)
@end example
is equivalent to
@example
fftw(plan, 1, in, 1, 0, out, 1, 0)
@end example

@node    fftw_destroy_plan, What FFTW Really Computes, fftw, One-dimensional Transforms Reference
@subsection Destroying a One-dimensional Plan

@example
#include <fftw.h>

void fftw_destroy_plan(fftw_plan plan);
@end example
@tindex fftw_destroy_plan

The function @code{fftw_destroy_plan} frees the plan @code{plan} and
releases all the memory associated with it.  After destruction, a plan
is no longer valid.

@node What FFTW Really Computes,  , fftw_destroy_plan, One-dimensional Transforms Reference
@subsection What FFTW Really Computes
@cindex Discrete Fourier Transform
In this section, we define precisely what FFTW computes.  Please be
warned that different authors and software packages might employ
different conventions than FFTW does.

The forward transform of a complex array @math{X} of size
@math{n} computes an array @math{Y}, where
@tex
$$
Y_i = \sum_{j = 0}^{n - 1} X_j e^{-2\pi i j \sqrt{-1}/n} \ .
$$
@end tex
@ifinfo
@center Y[i] = sum for j = 0 to (n - 1) of X[j] * exp(-2 pi i j sqrt(-1)/n) .
@end ifinfo
@ifhtml
<center><IMG SRC="equation-1.gif" ALIGN="top"></center>
@end ifhtml

The backward transform computes
@tex
$$
Y_i = \sum_{j = 0}^{n - 1} X_j e^{2\pi i j \sqrt{-1}/n} \ .
$$
@end tex
@ifinfo
@center Y[i] = sum for j = 0 to (n - 1) of X[j] * exp(2 pi i j sqrt(-1)/n) .
@end ifinfo
@ifhtml
<center><IMG SRC="equation-2.gif" ALIGN="top"></center>
@end ifhtml

@cindex normalization
FFTW computes an unnormalized transform, that is, the equation
@math{IFFT(FFT(X)) = n X} holds.  In other words, applying the forward
and then the backward transform will multiply the input by @math{n}.

@cindex frequency
An @code{FFTW_FORWARD} transform corresponds to a sign of @math{-1} in
the exponent of the DFT.  Note also that we use the standard
``in-order'' output ordering---the @math{k}-th output corresponds to the
frequency @math{k/n} (or @math{k/T}, where @math{T} is your total
sampling period).  For those who like to think in terms of positive and
negative frequencies, this means that the positive frequencies are
stored in the first half of the output and the negative frequencies are
stored in backwards order in the second half of the output.  (The
frequency @math{-k/n} is the same as the frequency @math{(n-k)/n}.)

@c -------------------------------------------------------
@node Multi-dimensional Transforms Reference, Real One-dimensional Transforms Reference, One-dimensional Transforms Reference, FFTW Reference
@section Multi-dimensional Transforms Reference
@cindex complex multi-dimensional transform
@cindex multi-dimensional transform
The multi-dimensional complex routines are generally prefixed with
@code{fftwnd_}.  Programs using FFTWND should be linked with @code{-lfftw
-lm} on Unix systems, or with the FFTW and standard math libraries in
general.
@cindex FFTWND

@menu
* fftwnd_create_plan::          Plan Creation
* fftwnd::                      Plan Execution
* fftwnd_destroy_plan::         Plan Destruction
* What FFTWND Really Computes::  
@end menu

@node   fftwnd_create_plan, fftwnd, Multi-dimensional Transforms Reference, Multi-dimensional Transforms Reference
@subsection Plan Creation for Multi-dimensional Transforms

@example
#include <fftw.h>

fftwnd_plan fftwnd_create_plan(int rank, const int *n,
                               fftw_direction dir, int flags);

fftwnd_plan fftw2d_create_plan(int nx, int ny,
                               fftw_direction dir, int flags);

fftwnd_plan fftw3d_create_plan(int nx, int ny, int nz,
                               fftw_direction dir, int flags);

fftwnd_plan fftwnd_create_plan_specific(int rank, const int *n,
                                        fftw_direction dir,
                                        int flags,
                                        fftw_complex *in, int istride,
                                        fftw_complex *out, int ostride);

fftwnd_plan fftw2d_create_plan_specific(int nx, int ny,
                                        fftw_direction dir,
                                        int flags,
                                        fftw_complex *in, int istride,
                                        fftw_complex *out, int ostride);

fftwnd_plan fftw3d_create_plan_specific(int nx, int ny, int nz,
                                        fftw_direction dir, int flags,
                                        fftw_complex *in, int istride,
                                        fftw_complex *out, int ostride);
@end example
@tindex fftwnd_plan
@tindex fftw_direction
@findex fftwnd_create_plan
@findex fftw2d_create_plan
@findex fftw3d_create_plan
@findex fftwnd_create_plan_specific
@findex fftw2d_create_plan_specific
@findex fftw3d_create_plan_specific

The function @code{fftwnd_create_plan} creates a plan, which is a data
structure containing all the information that @code{fftwnd} needs in
order to compute a multi-dimensional Fourier transform.  You can create
as many plans as you need, but only one plan for a given array size is
required (a plan can be reused many times).  The functions
@code{fftw2d_create_plan} and @code{fftw3d_create_plan} are optional,
alternative interfaces to @code{fftwnd_create_plan} for two and three
dimensions, respectively.

@code{fftwnd_create_plan} returns a valid plan, or @code{NULL} if, for
some reason, the plan can't be created.  This can happen if memory runs
out or if the arguments are invalid in some way (e.g.  if @code{rank} <
0).

The @code{create_plan_specific} variants take as additional arguments
specific input/output arrays and their strides.  For the last four
arguments, you should pass the arrays and strides that you will
eventually be passing to @code{fftwnd}.  The resulting plans will be
optimized for those arrays and strides, although they may be used on
other arrays as well.  Note: the contents of the in and out arrays are
@emph{destroyed} by the specific planner (the initial contents are
ignored, so the arrays need not have been initialized).
@xref{Discussion on Specific Plans}, for a discussion on specific plans.

@subsubheading Arguments
@itemize @bullet
@item
@code{rank} is the dimensionality of the arrays to be transformed.  It
can be any non-negative integer.

@item
@code{n} is a pointer to an array of @code{rank} integers, giving the
size of each dimension of the arrays to be transformed.  These sizes,
which must be positive integers, correspond to the dimensions of
@cindex row-major
row-major arrays---i.e. @code{n[0]} is the size of the dimension whose
indices vary most slowly, and so on. (@xref{Multi-dimensional Array
Format}, for more information on row-major storage.)
@xref{fftw_create_plan,,Plan Creation for One-dimensional Transforms},
for more information regarding optimal array sizes.

@item
@code{nx} and @code{ny} in @code{fftw2d_create_plan} are positive
integers specifying the dimensions of the rank 2 array to be
transformed. i.e. they specify that the transform will operate on
@code{nx x ny} arrays in row-major order, where @code{nx} is the number
of rows and @code{ny} is the number of columns.

@item
@code{nx}, @code{ny} and @code{nz} in @code{fftw3d_create_plan} are
positive integers specifying the dimensions of the rank 3 array to be
transformed. i.e. they specify that the transform will operate on
@code{nx x ny x nz} arrays in row-major order.

@item
@code{dir} is the sign of the exponent in the formula that defines the
Fourier transform.  It can be @math{-1} or @math{+1}.  The aliases
@code{FFTW_FORWARD} and @code{FFTW_BACKWARD} are provided, where
@code{FFTW_FORWARD} stands for @math{-1}.

@item
@cindex flags
@code{flags} is a boolean OR (@samp{|}) of zero or more of the following:
@itemize @minus
@item
@code{FFTW_MEASURE}: this flag tells FFTW to find the optimal plan by
actually @emph{computing} several FFTs and measuring their execution
time.

@item
@code{FFTW_ESTIMATE}: do not run any FFT and provide a ``reasonable''
plan (for a RISC processor with many registers).  If neither
@code{FFTW_ESTIMATE} nor @code{FFTW_MEASURE} is provided, the default is
@code{FFTW_ESTIMATE}.

@item
@code{FFTW_OUT_OF_PLACE}: produce a plan assuming that the input
  and output arrays will be distinct (this is the default).

@item
@code{FFTW_IN_PLACE}: produce a plan assuming that you want to perform
the transform in-place.  (Unlike the one-dimensional transform, this
``really'' @footnote{@code{fftwnd} actually may use some temporary
storage (hidden in the plan), but this storage space is only the size of
the largest dimension of the array, rather than being as big as the
entire array.  (Unless you use @code{fftwnd} to perform one-dimensional
transforms, in which case the temporary storage required for in-place
transforms @emph{is} as big as the entire array.)} performs the
transform in-place.) Note that, if you want to perform in-place
transforms, you @emph{must} use a plan created with this option.

The default mode of operation is @code{FFTW_OUT_OF_PLACE}.

@item
@cindex wisdom
@code{FFTW_USE_WISDOM}: use any @code{wisdom} that is available to help
in the creation of the plan. (@xref{Words of Wisdom}.)  This can greatly
speed the creation of plans, especially with the @code{FFTW_MEASURE}
option. @code{FFTW_ESTIMATE} plans can also take advantage of
@code{wisdom} to produce a more optimal plan (based on past
measurements) than the estimation heuristic would normally
generate. When the @code{FFTW_MEASURE} option is used, new @code{wisdom}
will also be generated if the current transform size is not completely
understood by existing @code{wisdom}. Note that the same @code{wisdom}
is shared between one-dimensional and multi-dimensional transforms.

@end itemize

@item
@code{in}, @code{out}, @code{istride}, @code{ostride} (only for the
@code{_create_plan_specific} variants): see corresponding arguments in
the description of @code{fftwnd}.  (@xref{fftwnd,,Computing the
Multi-dimensional Transform}.)

@end itemize

@node    fftwnd, fftwnd_destroy_plan, fftwnd_create_plan, Multi-dimensional Transforms Reference
@subsection Computing the Multi-dimensional Transform

@example
#include <fftw.h>

void fftwnd(fftwnd_plan plan, int howmany,
            fftw_complex *in, int istride, int idist,
            fftw_complex *out, int ostride, int odist);

void fftwnd_one(fftwnd_plan p, fftw_complex *in, 
                fftw_complex *out);
@end example
@findex fftwnd
@findex fftwnd_one

The function @code{fftwnd} computes one or more multi-dimensional
Fourier Transforms, using a plan created by @code{fftwnd_create_plan}
(@pxref{fftwnd_create_plan,,Plan Creation for Multi-dimensional
Transforms}). (Note that the plan determines the rank and dimensions of
the array to be transformed.)  The function @code{fftwnd_one} provides a
simplified interface for the common case of single input array of stride
1.
@cindex stride

@subsubheading Arguments
@itemize @bullet
@item
@code{plan} is the plan created by @code{fftwnd_create_plan}.
(@pxref{fftwnd_create_plan,,Plan Creation for Multi-dimensional
Transforms}). In the case of two and three-dimensional transforms, it
could also have been created by @code{fftw2d_create_plan} or
@code{fftw3d_create_plan}, respectively.

@item
@code{howmany} is the number of multi-dimensional transforms
@code{fftwnd} will compute.

@item
@code{in}, @code{istride} and @code{idist} describe the input array(s).
There are @code{howmany} multi-dimensional input arrays; the first one
is pointed to by @code{in}, the second one is pointed to by @code{in +
idist}, and so on, up to @code{in + (howmany - 1) * idist}.  Each
multi-dimensional input array consists of complex numbers (@pxref{Data
Types}), stored in row-major format (@pxref{Multi-dimensional Array
Format}), which are not necessarily contiguous in memory.  Specifically,
@code{in[0]} is the first element of the first array, @code{in[istride]}
is the second element of the first array, and so on.  In general, the
@code{i}-th element of the @code{j}-th input array will be in position
@code{in[i * istride + j * idist]}. Note that, here, @code{i} refers to
an index into the row-major format for the multi-dimensional array,
rather than an index in any particular dimension.

@itemize @minus
@item @emph{In-place transforms}:
@cindex in-place transform
For plans created with the @code{FFTW_IN_PLACE} option, the transform is
computed in-place---the output is returned in the @code{in} array, using
the same strides, etcetera, as were used in the input.
@end itemize

@item
@code{out}, @code{ostride} and @code{odist} describe the output array(s).
The format is the same as for the input array.

@itemize @minus
@item @emph{In-place transforms}:
These parameters are ignored for plans created with the
@code{FFTW_IN_PLACE} option.
@end itemize

@end itemize

The function @code{fftwnd_one} transforms a single, contiguous input
array to a contiguous output array.  By definition, the call
@example
fftwnd_one(plan, in, out)
@end example
is equivalent to
@example
fftwnd(plan, 1, in, 1, 0, out, 1, 0)
@end example

@node    fftwnd_destroy_plan, What FFTWND Really Computes, fftwnd, Multi-dimensional Transforms Reference
@subsection Destroying a Multi-dimensional Plan

@example
#include <fftw.h>

void fftwnd_destroy_plan(fftwnd_plan plan);
@end example
@findex fftwnd_destroy_plan

The function @code{fftwnd_destroy_plan} frees the plan @code{plan}
and releases all the memory associated with it.  After destruction,
a plan is no longer valid.

@node What FFTWND Really Computes,  , fftwnd_destroy_plan, Multi-dimensional Transforms Reference
@subsection What FFTWND Really Computes
@cindex Discrete Fourier Transform

The conventions that we follow for the multi-dimensional transform are
analogous to those for the one-dimensional transform. In particular, the
forward transform has a negative sign in the exponent and neither the
forward nor the backward transforms will perform any normalization.
Computing the backward transform of the forward transform will multiply
the array by the product of its dimensions.  The output is in-order, and
the zeroth element of the output is the amplitude of the zero frequency
component.

@tex
The exact mathematical definition of our multi-dimensional transform
follows.  Let $X$ be a $d$-dimensional complex array whose elements are
$X[j_1, j_2, \ldots, j_d]$, where $0 \leq j_s < n_s$ for all~$s \in \{
1, 2, \ldots, d \}$.  Let also $\omega_s = e^{2\pi \sqrt{-1}/n_s}$, for
all ~$s \in \{ 1, 2, \ldots, d \}$.

The forward transform computes a complex array~$Y$, whose
structure is the same as that of~$X$, defined by

$$
Y[i_1, i_2, \ldots, i_d] =
    \sum_{j_1 = 0}^{n_1 - 1}
        \sum_{j_2 = 0}^{n_2 - 1}
           \cdots
              \sum_{j_d = 0}^{n_d - 1}
                  X[j_1, j_2, \ldots, j_d] 
                      \omega_1^{-i_1 j_1}
                      \omega_2^{-i_2 j_2}
                      \cdots
                      \omega_d^{-i_d j_d} \ .
$$

The backward transform computes
$$
Y[i_1, i_2, \ldots, i_d] =
    \sum_{j_1 = 0}^{n_1 - 1}
        \sum_{j_2 = 0}^{n_2 - 1}
           \cdots
              \sum_{j_d = 0}^{n_d - 1}
                  X[j_1, j_2, \ldots, j_d] 
                      \omega_1^{i_1 j_1}
                      \omega_2^{i_2 j_2}
                      \cdots
                      \omega_d^{i_d j_d} \ .
$$

Computing the forward transform followed by the backward transform
will multiply the array by $\prod_{s=1}^{d} n_d$.
@end tex
@ifinfo
The @TeX{} version of this manual contains the exact definition of the
@math{n}-dimensional transform FFTW uses.  It is not possible to
display the definition on a ASCII terminal properly.
@end ifinfo
@ifhtml
The Gods forbade using HTML to display mathematical formulas.  Please
see the TeX or Postscript version of this manual for the proper
definition of the n-dimensional Fourier transform that FFTW
uses.  For completeness, we include a bitmap of the TeX output below:
<P><center><IMG SRC="equation-3.gif" ALIGN="top"></center>
@end ifhtml

@c -------------------------------------------------------
@node Real One-dimensional Transforms Reference, Real Multi-dimensional Transforms Reference, Multi-dimensional Transforms Reference, FFTW Reference
@section Real One-dimensional Transforms Reference

The one-dimensional real routines are generally prefixed with
@code{rfftw_}. @footnote{The etymologically-correct spelling would be
@code{frftw_}, but it is hard to remember.}  Programs using RFFTW
should be linked with @code{-lrfftw -lfftw -lm} on Unix systems, or with
the RFFTW, the FFTW, and the standard math libraries in general.
@cindex RFFTW
@cindex real transform
@cindex complex to real transform

@menu
* rfftw_create_plan::           Plan Creation   
* rfftw::                       Plan Execution  
* rfftw_destroy_plan::          Plan Destruction
* What RFFTW Really Computes::  
@end menu

@node    rfftw_create_plan, rfftw, Real One-dimensional Transforms Reference, Real One-dimensional Transforms Reference
@subsection Plan Creation for Real One-dimensional Transforms

@example
#include <rfftw.h>

rfftw_plan rfftw_create_plan(int n, fftw_direction dir, int flags);

rfftw_plan rfftw_create_plan_specific(int n, fftw_direction dir,
	    int flags, fftw_real *in, int istride,
	    fftw_real *out, int ostride);
@end example
@tindex rfftw_plan
@findex rfftw_create_plan
@findex rfftw_create_plan_specific

The function @code{rfftw_create_plan} creates a plan, which is a data
structure containing all the information that @code{rfftw} needs in
order to compute the 1D real Fourier transform. You can create as many
plans as you need, but only one plan for a given array size is required
(a plan can be reused many times).

@code{rfftw_create_plan} returns a valid plan, or @code{NULL} if, for
some reason, the plan can't be created.  In the default installation,
this cannot happen, but it is possible to configure RFFTW in such a way
that some input sizes are forbidden, and RFFTW cannot create a plan.

The @code{rfftw_create_plan_specific} variant takes as additional
arguments specific input/output arrays and their strides.  For the last
four arguments, you should pass the arrays and strides that you will
eventually be passing to @code{rfftw}.  The resulting plans will be
optimized for those arrays and strides, although they may be used on
other arrays as well.  Note: the contents of the in and out arrays are
@emph{destroyed} by the specific planner (the initial contents are
ignored, so the arrays need not have been initialized).
@xref{Discussion on Specific Plans}, for a discussion on specific plans.

@subsubheading Arguments
@itemize @bullet
@item
@code{n} is the size of the transform.  It can be
 any positive integer.
 
@itemize @minus
@item
RFFTW is best at handling sizes of the form
@ifinfo
@math{2^a 3^b 5^c 7^d 11^e 13^f},
@end ifinfo
@tex
$2^a 3^b 5^c 7^d 11^e 13^f$,
@end tex
@ifhtml
2<SUP>a</SUP> 3<SUP>b</SUP> 5<SUP>c</SUP> 7<SUP>d</SUP>
        11<SUP>e</SUP> 13<SUP>f</SUP>,
@end ifhtml
where @math{e+f} is either @math{0} or
@math{1}, and the other exponents are arbitrary.  Other sizes are
computed by means of a slow, general-purpose routine (reducing to
@ifinfo
@math{O(n^2)}
@end ifinfo
@tex
$O(n^2)$
@end tex
@ifhtml
O(n<sup>2</sup>)
@end ifhtml
performance for prime sizes).  (It is possible to customize RFFTW for
different array sizes.  @xref{Installation and Customization}, for more
information.)  Transforms whose sizes are powers of @math{2} are
especially fast.  If you have large prime factors, it may be faster to
switch over to the complex FFTW routines, which have
@iftex
@tex
$O(n \log n)$
@end tex
@end iftex
@ifinfo
O(n lg n)
@end ifinfo
@ifhtml
O(n lg n)
@end ifhtml
performance even for prime sizes (we don't know of a similar algorithm
specialized for real data, unfortunately).

@end itemize

@item
@code{dir} is the direction of the desired transform, either
@code{FFTW_REAL_TO_COMPLEX} or @code{FFTW_COMPLEX_TO_REAL},
corresponding to @code{FFTW_FORWARD} or @code{FFTW_BACKWARD},
respectively.
@ctindex FFTW_REAL_TO_COMPLEX
@ctindex FFTW_COMPLEX_TO_REAL

@item
@cindex flags
@code{flags} is a boolean OR (@samp{|}) of zero or more of the following:
@itemize @minus
@item
@code{FFTW_MEASURE}: this flag tells RFFTW to find the optimal plan by
actually @emph{computing} several FFTs and measuring their
execution time.  Depending on the installation, this can take some
time.

@item
@code{FFTW_ESTIMATE}: do not run any FFT and provide a ``reasonable''
plan (for a RISC processor with many registers).  If neither
@code{FFTW_ESTIMATE} nor @code{FFTW_MEASURE} is provided, the default is
@code{FFTW_ESTIMATE}.

@item
@code{FFTW_OUT_OF_PLACE}: produce a plan assuming that the input
  and output arrays will be distinct (this is the default).

@item
@code{FFTW_IN_PLACE}: produce a plan assuming that you want the output
in the input array.  The algorithm used is not necessarily in place:
RFFTW is able to compute true in-place transforms only for small values
of @code{n}.  If RFFTW is not able to compute the transform in-place, it
will allocate a temporary array (unless you provide one yourself),
compute the transform out of place, and copy the result back.
@emph{Warning: This option changes the meaning of some parameters of
@code{rfftw}} (@pxref{rfftw,,Computing the Real One-dimensional Transform}).

The default mode of operation is @code{FFTW_OUT_OF_PLACE}.

@item
@code{FFTW_USE_WISDOM}: use any @code{wisdom} that is available to help
in the creation of the plan. (@xref{Words of Wisdom}.)
This can greatly speed the creation of plans, especially with the
@code{FFTW_MEASURE} option. @code{FFTW_ESTIMATE} plans can also take
advantage of @code{wisdom} to produce a more optimal plan (based on past
measurements) than the estimation heuristic would normally
generate. When the @code{FFTW_MEASURE} option is used, new @code{wisdom}
will also be generated if the current transform size is not completely
understood by existing @code{wisdom}.

@end itemize

@item
@code{in}, @code{out}, @code{istride}, @code{ostride} (only for
@code{rfftw_create_plan_specific}): see corresponding arguments in the
description of @code{rfftw}.  (@xref{rfftw,,Computing the Real
One-dimensional Transform}.)  In particular, the @code{out} and
@code{ostride} parameters have the same special meaning for
@code{FFTW_IN_PLACE} transforms as they have for @code{rfftw}.

@end itemize

@node    rfftw, rfftw_destroy_plan, rfftw_create_plan, Real One-dimensional Transforms Reference
@subsection Computing the Real One-dimensional Transform

@example
#include <rfftw.h>

void rfftw(rfftw_plan plan, int howmany, 
           fftw_real *in, int istride, int idist, 
           fftw_real *out, int ostride, int odist);

void rfftw_one(rfftw_plan plan, fftw_real *in, fftw_real *out);
@end example
@findex rfftw
@findex rfftw_one

The function @code{rfftw} computes the Real One-dimensional Fourier
Transform, using a plan created by @code{rfftw_create_plan}
(@pxref{rfftw_create_plan,,Plan Creation for Real One-dimensional
Transforms}).  The function @code{rfftw_one} provides a simplified
interface for the common case of single input array of stride 1.
@cindex stride

@emph{Important:} When invoked for an out-of-place,
@code{FFTW_COMPLEX_TO_REAL} transform, the input array is overwritten
with scratch values by these routines.  The input array is not modified
for @code{FFTW_REAL_TO_COMPLEX} transforms.

@subsubheading Arguments
@itemize @bullet
@item
@code{plan} is the plan created by @code{rfftw_create_plan}
(@pxref{rfftw_create_plan,,Plan Creation for Real One-dimensional
Transforms}).

@item
@code{howmany} is the number of transforms @code{rfftw} will compute.
It is faster to tell RFFTW to compute many transforms, instead of
simply calling @code{rfftw} many times.

@item
@code{in}, @code{istride} and @code{idist} describe the input array(s).
There are two cases.  If the @code{plan} defines a
@code{FFTW_REAL_TO_COMPLEX} transform, @code{in} is a real array.
Otherwise, for @code{FFTW_COMPLEX_TO_REAL} transforms, @code{in} is a
halfcomplex array @emph{whose contents will be destroyed}.

@item
@code{out}, @code{ostride} and @code{odist} describe the output
array(s), and have the same meaning as the corresponding parameters for
the input array.

@itemize @minus
@item @emph{In-place transforms}:
If the @code{plan} specifies an in-place transform, @code{ostride} and
@code{odist} are always ignored.  If @code{out} is @code{NULL},
@code{out} is ignored, too.  Otherwise, @code{out} is interpreted as a
pointer to an array of @code{n} complex numbers, that FFTW will use as
temporary space to perform the in-place computation.  @code{out} is used
as scratch space and its contents destroyed.  In this case, @code{out}
must be an ordinary array whose elements are contiguous in memory (no
striding).
@end itemize

@end itemize

The function @code{rfftw_one} transforms a single, contiguous input array
to a contiguous output array.  By definition, the call
@example
rfftw_one(plan, in, out)
@end example
is equivalent to
@example
rfftw(plan, 1, in, 1, 0, out, 1, 0)
@end example

@node    rfftw_destroy_plan, What RFFTW Really Computes, rfftw, Real One-dimensional Transforms Reference
@subsection Destroying a Real One-dimensional Plan

@example
#include <rfftw.h>

void rfftw_destroy_plan(rfftw_plan plan);
@end example
@findex rfftw_destroy_plan

The function @code{rfftw_destroy_plan} frees the plan @code{plan} and
releases all the memory associated with it.  After destruction, a plan
is no longer valid.

@node What RFFTW Really Computes,  , rfftw_destroy_plan, Real One-dimensional Transforms Reference
@subsection What RFFTW Really Computes
@cindex Discrete Fourier Transform
In this section, we define precisely what RFFTW computes. 

The real to complex (@code{FFTW_REAL_TO_COMPLEX}) transform of a real
array @math{X} of size @math{n} computes an hermitian array @math{Y},
where
@tex
$$
Y_i = \sum_{j = 0}^{n - 1} X_j e^{-2\pi i j \sqrt{-1}/n}
$$
@end tex
@ifinfo
@center Y[i] = sum for j = 0 to (n - 1) of X[j] * exp(-2 pi i j sqrt(-1)/n)
@end ifinfo
@ifhtml
<center><IMG SRC="equation-1.gif" ALIGN="top"></center>
@end ifhtml
(That @math{Y} is a hermitian array is not intended to be obvious,
although the proof is easy.)  The hermitian array @math{Y} is stored in
halfcomplex order (@pxref{Data Types}).  Currently, RFFTW provides no
way to compute a real to complex transform with a positive sign in the
exponent.

The complex to real (@code{FFTW_COMPLEX_TO_REAL}) transform of a hermitian
array @math{X} of size @math{n} computes a real array @math{Y}, where
@tex
$$
Y_i = \sum_{j = 0}^{n - 1} X_j e^{2\pi i j \sqrt{-1}/n}
$$
@end tex
@ifinfo
@center Y[i] = sum for j = 0 to (n - 1) of X[j] * exp(2 pi i j sqrt(-1)/n)
@end ifinfo
@ifhtml
<center><IMG SRC="equation-2.gif" ALIGN="top"></center>
@end ifhtml
(That @math{Y} is a real array is not intended to be obvious, although
the proof is easy.)  The hermitian input array @math{X} is stored in
halfcomplex order (@pxref{Data Types}).  Currently, RFFTW provides no
way to compute a complex to real transform with a negative sign in the
exponent.

@cindex normalization
Like FFTW, RFFTW computes an unnormalized transform.  In other words,
applying the real to complex (forward) and then the complex to real
(backward) transform will multiply the input by @math{n}.

@c -------------------------------------------------------
@node Real Multi-dimensional Transforms Reference, Wisdom Reference, Real One-dimensional Transforms Reference, FFTW Reference
@section Real Multi-dimensional Transforms Reference
@cindex real multi-dimensional transform
@cindex multi-dimensional transform

The multi-dimensional real routines are generally prefixed with
@code{rfftwnd_}.  Programs using RFFTWND should be linked with
@code{-lrfftw -lfftw -lm} on Unix systems, or with the FFTW, RFFTW, and
standard math libraries in general.
@cindex RFFTWND

@menu
* rfftwnd_create_plan::         Plan Creation
* rfftwnd::                     Plan Execution
* Array Dimensions for Real Multi-dimensional Transforms::  
* Strides in In-place RFFTWND::  
* rfftwnd_destroy_plan::        Plan Destruction
* What RFFTWND Really Computes::  
@end menu

@node   rfftwnd_create_plan, rfftwnd, Real Multi-dimensional Transforms Reference, Real Multi-dimensional Transforms Reference
@subsection Plan Creation for Real Multi-dimensional Transforms

@example
#include <rfftw.h>

rfftwnd_plan rfftwnd_create_plan(int rank, const int *n,
                                 fftw_direction dir, int flags);

rfftwnd_plan rfftw2d_create_plan(int nx, int ny,
                                 fftw_direction dir, int flags);

rfftwnd_plan rfftw3d_create_plan(int nx, int ny, int nz,
                                 fftw_direction dir, int flags);
@end example
@tindex rfftwnd_plan
@tindex fftw_direction
@findex rfftwnd_create_plan
@findex rfftw2d_create_plan
@findex rfftw3d_create_plan

The function @code{rfftwnd_create_plan} creates a plan, which is a data
structure containing all the information that @code{rfftwnd} needs in
order to compute a multi-dimensional real Fourier transform.  You can
create as many plans as you need, but only one plan for a given array
size is required (a plan can be reused many times).  The functions
@code{rfftw2d_create_plan} and @code{rfftw3d_create_plan} are optional,
alternative interfaces to @code{rfftwnd_create_plan} for two and three
dimensions, respectively.

@code{rfftwnd_create_plan} returns a valid plan, or @code{NULL} if, for
some reason, the plan can't be created.  This can happen if the
arguments are invalid in some way (e.g. if @code{rank} < 0).

@subsubheading Arguments
@itemize @bullet
@item
@code{rank} is the dimensionality of the arrays to be transformed.  It
can be any non-negative integer.

@item
@code{n} is a pointer to an array of @code{rank} integers, giving the
size of each dimension of the arrays to be transformed.  Note that these
are always the dimensions of the @emph{real} arrays; the complex arrays
have different dimensions (@pxref{Array Dimensions for Real
Multi-dimensional Transforms}).  These sizes, which must be positive
integers, correspond to the dimensions of row-major
arrays---i.e. @code{n[0]} is the size of the dimension whose indices
vary most slowly, and so on. (@xref{Multi-dimensional Array Format}, for
more information.)
@itemize @minus
@item
@xref{rfftw_create_plan,,Plan Creation for Real One-dimensional Transforms},
for more information regarding optimal array sizes.
@end itemize

@item
@code{nx} and @code{ny} in @code{rfftw2d_create_plan} are positive
integers specifying the dimensions of the rank 2 array to be
transformed. i.e. they specify that the transform will operate on
@code{nx x ny} arrays in row-major order, where @code{nx} is the number
of rows and @code{ny} is the number of columns.

@item
@code{nx}, @code{ny} and @code{nz} in @code{rfftw3d_create_plan} are
positive integers specifying the dimensions of the rank 3 array to be
transformed. i.e. they specify that the transform will operate on
@code{nx x ny x nz} arrays in row-major order.

@item
@code{dir} is the direction of the desired transform, either
@code{FFTW_REAL_TO_COMPLEX} or @code{FFTW_COMPLEX_TO_REAL},
corresponding to @code{FFTW_FORWARD} or @code{FFTW_BACKWARD},
respectively.

@item
@cindex flags
@code{flags} is a boolean OR (@samp{|}) of zero or more of the following:
@itemize @minus
@item
@code{FFTW_MEASURE}: this flag tells FFTW to find the optimal plan by
actually @emph{computing} several FFTs and measuring their execution
time.

@item
@code{FFTW_ESTIMATE}: do not run any FFT and provide a ``reasonable''
plan (for a RISC processor with many registers).  If neither
@code{FFTW_ESTIMATE} nor @code{FFTW_MEASURE} is provided, the default is
@code{FFTW_ESTIMATE}.

@item
@code{FFTW_OUT_OF_PLACE}: produce a plan assuming that the input
  and output arrays will be distinct (this is the default).

@item
@cindex in-place transform
@code{FFTW_IN_PLACE}: produce a plan assuming that you want to perform
the transform in-place.  (Unlike the one-dimensional transform, this
``really'' performs the transform in-place.) Note that, if you want to
perform in-place transforms, you @emph{must} use a plan created with
this option.  The use of this option has important implications for the
size of the input/output array (@pxref{rfftwnd,,Computing the Real
Multi-dimensional Transform}).

The default mode of operation is @code{FFTW_OUT_OF_PLACE}.

@item
@cindex wisdom
@code{FFTW_USE_WISDOM}: use any @code{wisdom} that is available to help
in the creation of the plan. (@xref{Words of Wisdom}.)  This can greatly
speed the creation of plans, especially with the @code{FFTW_MEASURE}
option. @code{FFTW_ESTIMATE} plans can also take advantage of
@code{wisdom} to produce a more optimal plan (based on past
measurements) than the estimation heuristic would normally
generate. When the @code{FFTW_MEASURE} option is used, new @code{wisdom}
will also be generated if the current transform size is not completely
understood by existing @code{wisdom}. Note that the same @code{wisdom}
is shared between one-dimensional and multi-dimensional transforms.

@end itemize

@end itemize

@node    rfftwnd, Array Dimensions for Real Multi-dimensional Transforms, rfftwnd_create_plan, Real Multi-dimensional Transforms Reference
@subsection Computing the Real Multi-dimensional Transform

@example
#include <rfftw.h>

void rfftwnd_real_to_complex(rfftwnd_plan plan, int howmany,
                             fftw_real *in, int istride, int idist,
                             fftw_complex *out, int ostride, int odist);
void rfftwnd_complex_to_real(rfftwnd_plan plan, int howmany,
                             fftw_complex *in, int istride, int idist,
                             fftw_real *out, int ostride, int odist);

void rfftwnd_one_real_to_complex(rfftwnd_plan p, fftw_real *in,
                                 fftw_complex *out);
void rfftwnd_one_complex_to_real(rfftwnd_plan p, fftw_complex *in,
                                 fftw_real *out);
@end example
@findex rfftwnd_real_to_complex
@findex rfftwnd_complex_to_real
@findex rfftwnd_one_real_to_complex
@findex rfftwnd_one_complex_to_real

These functions compute the real multi-dimensional Fourier Transform,
using a plan created by @code{rfftwnd_create_plan}
(@pxref{rfftwnd_create_plan,,Plan Creation for Real Multi-dimensional
Transforms}). (Note that the plan determines the rank and dimensions of
the array to be transformed.)  The @samp{@code{rfftwnd_one_}} functions
provide a simplified interface for the common case of single input array
of stride 1.  Unlike other transform routines in FFTW, we here use
separate functions for the two directions of the transform in order to
correctly express the datatypes of the parameters.

@emph{Important:} When invoked for an out-of-place,
@code{FFTW_COMPLEX_TO_REAL} transform with @code{rank > 1}, the input
array is overwritten with scratch values by these routines.  The input
array is not modified for @code{FFTW_REAL_TO_COMPLEX} transforms or for
@code{FFTW_COMPLEX_TO_REAL} with @code{rank == 1}.

@subsubheading Arguments
@itemize @bullet
@item
@code{plan} is the plan created by @code{rfftwnd_create_plan}.
(@pxref{rfftwnd_create_plan,,Plan Creation for Real Multi-dimensional
Transforms}). In the case of two and three-dimensional transforms, it
could also have been created by @code{rfftw2d_create_plan} or
@code{rfftw3d_create_plan}, respectively.

@code{FFTW_REAL_TO_COMPLEX} plans must be used with the
@samp{@code{real_to_complex}} functions, and @code{FFTW_COMPLEX_TO_REAL}
plans must be used with the @samp{@code{complex_to_real}} functions.  It
is an error to mismatch the plan direction and the transform function.

@item
@code{howmany} is the number of transforms to be computed.

@item
@cindex stride
@code{in}, @code{istride} and @code{idist} describe the input array(s).
There are @code{howmany} input arrays; the first one is pointed to by
@code{in}, the second one is pointed to by @code{in + idist}, and so on,
up to @code{in + (howmany - 1) * idist}.  Each input array is stored in
row-major format (@pxref{Multi-dimensional Array Format}), and is not
necessarily contiguous in memory.  Specifically, @code{in[0]} is the
first element of the first array, @code{in[istride]} is the second
element of the first array, and so on.  In general, the @code{i}-th
element of the @code{j}-th input array will be in position @code{in[i *
istride + j * idist]}. Note that, here, @code{i} refers to an index into
the row-major format for the multi-dimensional array, rather than an
index in any particular dimension.

The dimensions of the arrays are different for real and complex data,
and are discussed in more detail below (@pxref{Array Dimensions for Real
Multi-dimensional Transforms}).

@itemize @minus
@item @emph{In-place transforms}:
For plans created with the @code{FFTW_IN_PLACE} option, the transform is
computed in-place---the output is returned in the @code{in} array.  The
meaning of the @code{stride} and @code{dist} parameters in this case is
subtle and is discussed below (@pxref{Strides in In-place RFFTWND}).
@end itemize

@item
@code{out}, @code{ostride} and @code{odist} describe the output
array(s).  The format is the same as that for the input array.  See
below for a discussion of the dimensions of the output array for real
and complex data.

@itemize @minus
@item @emph{In-place transforms}:
These parameters are ignored for plans created with the
@code{FFTW_IN_PLACE} option.
@end itemize

@end itemize

The function @code{rfftwnd_one} transforms a single, contiguous input
array to a contiguous output array.  By definition, the call
@example
rfftwnd_one_...(plan, in, out)
@end example
is equivalent to
@example
rfftwnd_...(plan, 1, in, 1, 0, out, 1, 0)
@end example

@node Array Dimensions for Real Multi-dimensional Transforms, Strides in In-place RFFTWND, rfftwnd, Real Multi-dimensional Transforms Reference
@subsection Array Dimensions for Real Multi-dimensional Transforms

@cindex rfftwnd array format
The output of a multi-dimensional transform of real data contains
symmetries that, in principle, make half of the outputs redundant
(@pxref{What RFFTWND Really Computes}).  In practice, it is not
possible to entirely realize these savings in an efficient and
understandable format.  Instead, the output of the rfftwnd transforms is
@emph{slightly} over half of the output of the corresponding complex
transform.  We do not ``pack'' the data in any way, but store it as an
ordinary array of @code{fftw_complex} values.  In fact, this data is
simply a subsection of what would be the array in the corresponding
complex transform.

Specifically, for a real transform of dimensions
@tex
$n_1 \times n_2 \times \cdots \times n_d$,
@end tex
@ifinfo
n1 x n2 x ... x nd,
@end ifinfo
@ifhtml
n<sub>1</sub> x n<sub>2</sub> x ... x n<sub>d</sub>,
@end ifhtml
the complex data is an
@tex
$n_1 \times n_2 \times \cdots \times (n_d/2+1)$
@end tex
@ifinfo
n1 x n2 x ... x (nd/2+1)
@end ifinfo
@ifhtml
n<sub>1</sub> x n<sub>2</sub> x ... x (n<sub>d</sub>/2+1)
@end ifhtml
array of @code{fftw_complex} values in row-major order (with the
division rounded down).  That is, we only store the lower half (plus one
element) of the last dimension of the data from the ordinary complex
transform.  (We could have instead taken half of any other dimension,
but implementation turns out to be simpler if the last, contiguous,
dimension is used.)

@cindex in-place transform
@cindex padding
Since the complex data is slightly larger than the real data, some
complications arise for in-place transforms.  In this case, the final
dimension of the real data must be padded with extra values to
accommodate the size of the complex data---two extra if the last
dimension is even and one if it is odd.  That is, the last dimension of
the real data must physically contain
@tex
$2 (n_d/2+1)$
@end tex
@ifinfo
2 * (nd/2+1)
@end ifinfo
@ifhtml
2 * (n<sub>d</sub>/2+1)
@end ifhtml
@code{fftw_real} values (exactly enough to hold the complex data).
This physical array size does not, however, change the @emph{logical}
array size---only
@tex
$n_d$
@end tex
@ifinfo
nd
@end ifinfo
@ifhtml
n<sub>d</sub>
@end ifhtml
values are actually stored in the last dimension, and
@tex
$n_d$
@end tex
@ifinfo
nd
@end ifinfo
@ifhtml
n<sub>d</sub>
@end ifhtml
is the last dimension passed to @code{rfftwnd_create_plan}.

@node Strides in In-place RFFTWND, rfftwnd_destroy_plan, Array Dimensions for Real Multi-dimensional Transforms, Real Multi-dimensional Transforms Reference
@subsection Strides in In-place RFFTWND

@cindex rfftwnd array format
@cindex stride
The fact that the input and output datatypes are different for rfftwnd
complicates the meaning of the @code{stride} and @code{dist} parameters
of in-place transforms---are they in units of @code{fftw_real} or
@code{fftw_complex} elements?  When reading the input, they are
interpreted in units of the datatype of the input data.  When writing
the output, the @code{istride} and @code{idist} are translated to the
output datatype's ``units'' in one of two ways, corresponding to the two
most common situations in which @code{stride} and @code{dist} parameters
are useful.  Below, we refer to these ``translated'' parameters as
@code{ostride_t} and @code{odist_t}.  (Note that these are computed
internally by rfftwnd; the actual @code{ostride} and @code{odist}
parameters are ignored for in-place transforms.)

First, there is the case where you are transforming a number of
contiguous arrays located one after another in memory.  In this
situation, @code{istride} is @code{1} and @code{idist} is the product of
the physical dimensions of the array.  @code{ostride_t} and
@code{odist_t} are then chosen so that the output arrays are contiguous
and lie on top of the input arrays.  @code{ostride_t} is therefore
@code{1}.  For a real-to-complex transform, @code{odist_t} is
@code{idist/2}; for a complex-to-real transform, @code{odist_t} is
@code{idist*2}.

The second case is when you have an array in which each element has
@code{nc} components (e.g. a structure with @code{nc} numeric fields),
and you want to transform all of the components at once.  Here,
@code{istride} is @code{nc} and @code{idist} is @code{1}.  For this
case, it is natural to want the output to also have @code{nc}
consecutive components, now of the output data type; this is exactly
what rfftwnd does.  Specifically, it uses an @code{ostride_t} equal to
@code{istride}, and an @code{odist_t} of @code{1}.  (Astute readers will
realize that some extra buffer space is required in order to perform
such a transform; this is handled automatically by rfftwnd.)

The general rule is as follows.  @code{ostride_t} equals @code{istride}.
If @code{idist} is @code{1} and @code{idist} is less than
@code{istride}, then @code{odist_t} is @code{1}.  Otherwise, for a
real-to-complex transform @code{odist_t} is @code{idist/2} and for a
complex-to-real transform @code{odist_t} is @code{idist*2}.

@node    rfftwnd_destroy_plan, What RFFTWND Really Computes, Strides in In-place RFFTWND, Real Multi-dimensional Transforms Reference
@subsection Destroying a Multi-dimensional Plan

@example
#include <rfftw.h>

void rfftwnd_destroy_plan(rfftwnd_plan plan);
@end example
@findex rfftwnd_destroy_plan

The function @code{rfftwnd_destroy_plan} frees the plan @code{plan}
and releases all the memory associated with it.  After destruction,
a plan is no longer valid.

@node What RFFTWND Really Computes,  , rfftwnd_destroy_plan, Real Multi-dimensional Transforms Reference
@subsection What RFFTWND Really Computes
@cindex Discrete Fourier Transform

The conventions that we follow for the real multi-dimensional transform
are analogous to those for the complex multi-dimensional transform. In
particular, the forward transform has a negative sign in the exponent
and neither the forward nor the backward transforms will perform any
normalization.  Computing the backward transform of the forward
transform will multiply the array by the product of its dimensions (that
is, the logical dimensions of the real data).  The forward transform is
real-to-complex and the backward transform is complex-to-real.

@cindex Discrete Fourier Transform
@cindex hermitian array
@tex
The exact mathematical definition of our real multi-dimensional
transform follows. 

@noindent@emph{Real to complex (forward) transform.}
Let $X$ be a $d$-dimensional real array whose elements are $X[j_1, j_2,
\ldots, j_d]$, where $0 \leq j_s < n_s$ for all~$s \in \{ 1, 2, \ldots,
d \}$.  Let also $\omega_s = e^{2\pi \sqrt{-1}/n_s}$, for all ~$s \in \{
1, 2, \ldots, d \}$.

The real to complex transform computes a complex array~$Y$, whose
structure is the same as that of~$X$, defined by

$$
Y[i_1, i_2, \ldots, i_d] =
    \sum_{j_1 = 0}^{n_1 - 1}
        \sum_{j_2 = 0}^{n_2 - 1}
           \cdots
              \sum_{j_d = 0}^{n_d - 1}
                  X[j_1, j_2, \ldots, j_d] 
                      \omega_1^{-i_1 j_1}
                      \omega_2^{-i_2 j_2}
                      \cdots
                      \omega_d^{-i_d j_d} \ .
$$

The output array $Y$ enjoys a multidimensional hermitian symmetry, that
is, the identity $Y[i_1, i_2, \ldots, i_d] = Y[n_1-i_1, n_2-i_2, \ldots,
n_d - i_d]^{*}$ holds for all $0 \leq i_s < n_s$.  Because of this
symmetry, $Y$ is stored in the peculiar way described in @ref{Array
Dimensions for Real Multi-dimensional Transforms}.
@cindex hermitian array

@noindent@emph{Complex to real (backward) transform.}  Let $X$ be a
$d$-dimensional complex array whose elements are $X[j_1, j_2, \ldots,
j_d]$, where $0 \leq j_s < n_s$ for all~$s \in \{ 1, 2, \ldots, d \}$.
The array $X$ must be hermitian, that is, the identity $X[j_1, j_2,
\ldots, j_d] = X[n_1-j_1, n_2-j_2, \ldots, n_d - j_d]^{*}$ must hold for all
$0 \leq j_s < n_s$.  Moreover, $X$ must be stored in memory in the
peculiar way described in @ref{Array Dimensions for Real
Multi-dimensional Transforms}.

Let $\omega_s = e^{2\pi \sqrt{-1}/n_s}$, for all ~$s \in \{ 1, 2,
\ldots, d \}$.  The complex to real transform computes a real array~$Y$, whose
structure is the same as that of~$X$, defined by

$$
Y[i_1, i_2, \ldots, i_d] =
    \sum_{j_1 = 0}^{n_1 - 1}
        \sum_{j_2 = 0}^{n_2 - 1}
           \cdots
              \sum_{j_d = 0}^{n_d - 1}
                  X[j_1, j_2, \ldots, j_d] 
                      \omega_1^{i_1 j_1}
                      \omega_2^{i_2 j_2}
                      \cdots
                      \omega_d^{i_d j_d} \ .
$$

(That $Y$ is real is not meant to be obvious, although the proof is
easy.)

Computing the forward transform followed by the backward transform
will multiply the array by $\prod_{s=1}^{d} n_d$.
@end tex
@ifinfo
The @TeX{} version of this manual contains the exact definition of the
@math{n}-dimensional transform RFFTWND uses.  It is not possible to
display the definition on a ASCII terminal properly.
@end ifinfo
@ifhtml
The Gods forbade using HTML to display mathematical formulas.  Please
see the TeX or Postscript version of this manual for the proper
definition of the n-dimensional real Fourier transform that RFFTW
uses.  For completeness, we include a bitmap of the TeX output below:
<P><center><IMG SRC="equation-4.gif" ALIGN="top"></center>
@end ifhtml


@c -------------------------------------------------------
@node Wisdom Reference, Memory Allocator Reference, Real Multi-dimensional Transforms Reference, FFTW Reference
@section Wisdom Reference
@menu
* fftw_export_wisdom::          
* fftw_import_wisdom::          
* fftw_forget_wisdom::          
@end menu

@cindex wisdom
@node    fftw_export_wisdom, fftw_import_wisdom, Wisdom Reference, Wisdom Reference
@subsection Exporting Wisdom

@example
#include <fftw.h>

void fftw_export_wisdom(void (*emitter)(char c, void *), void *data);
void fftw_export_wisdom_to_file(FILE *output_file);
char *fftw_export_wisdom_to_string(void);
@end example
@findex fftw_export_wisdom
@findex fftw_export_wisdom_to_file
@findex fftw_export_wisdom_to_string

These functions allow you to export all currently accumulated
@code{wisdom} in a form from which it can be later imported and
restored, even during a separate run of the program. (@xref{Words of Wisdom}.)  The current store of @code{wisdom} is not
affected by calling any of these routines.

@code{fftw_export_wisdom} exports the @code{wisdom} to any output
medium, as specified by the callback function
@code{emitter}. @code{emitter} is a @code{putc}-like function that
writes the character @code{c} to some output; its second parameter is
the @code{data} pointer passed to @code{fftw_export_wisdom}.  For
convenience, the following two ``wrapper'' routines are provided:

@code{fftw_export_wisdom_to_file} writes the @code{wisdom} to the
current position in @code{output_file}, which should be open with write
permission.  Upon exit, the file remains open and is positioned at the
end of the @code{wisdom} data.

@code{fftw_export_wisdom_to_string} returns a pointer to a
@code{NULL}-terminated string holding the @code{wisdom} data. This
string is dynamically allocated, and it is the responsibility of the
caller to deallocate it with @code{fftw_free} when it is no longer
needed.

All of these routines export the wisdom in the same format, which we
will not document here except to say that it is LISP-like ASCII text
that is insensitive to white space.

@node    fftw_import_wisdom, fftw_forget_wisdom, fftw_export_wisdom, Wisdom Reference
@subsection Importing Wisdom

@example
#include <fftw.h>

fftw_status fftw_import_wisdom(int (*get_input)(void *), void *data);
fftw_status fftw_import_wisdom_from_file(FILE *input_file);
fftw_status fftw_import_wisdom_from_string(const char *input_string);
@end example
@findex fftw_import_wisdom
@findex fftw_import_wisdom_from_file
@findex fftw_import_wisdom_from_string

These functions import @code{wisdom} into a program from data stored by
the @code{fftw_export_wisdom} functions above. (@xref{Words of Wisdom}.)
The imported @code{wisdom} supplements rather than replaces any
@code{wisdom} already accumulated by the running program (except when
there is conflicting @code{wisdom}, in which case the existing wisdom is
replaced).

@code{fftw_import_wisdom} imports @code{wisdom} from any input medium,
as specified by the callback function @code{get_input}. @code{get_input}
is a @code{getc}-like function that returns the next character in the
input; its parameter is the @code{data} pointer passed to
@code{fftw_import_wisdom}. If the end of the input data is reached
(which should never happen for valid data), it may return either
@code{NULL} (ASCII 0) or @code{EOF} (as defined in @code{<stdio.h>}).
For convenience, the following two ``wrapper'' routines are provided:

@code{fftw_import_wisdom_from_file} reads @code{wisdom} from the
current position in @code{input_file}, which should be open with read
permission.  Upon exit, the file remains open and is positioned at the
end of the @code{wisdom} data.

@code{fftw_import_wisdom_from_string} reads @code{wisdom} from the
@code{NULL}-terminated string @code{input_string}.

The return value of these routines is @code{FFTW_SUCCESS} if the wisdom
was read successfully, and @code{FFTW_FAILURE} otherwise. Note that, in
all of these functions, any data in the input stream past the end of the
@code{wisdom} data is simply ignored (it is not even read if the
@code{wisdom} data is well-formed).

@node    fftw_forget_wisdom,  , fftw_import_wisdom, Wisdom Reference
@subsection Forgetting Wisdom

@example
#include <fftw.h>

void fftw_forget_wisdom(void);
@end example
@findex fftw_forget_wisdom

Calling @code{fftw_forget_wisdom} causes all accumulated @code{wisdom}
to be discarded and its associated memory to be freed. (New
@code{wisdom} can still be gathered subsequently, however.)

@c -------------------------------------------------------
@node    Memory Allocator Reference, Thread safety, Wisdom Reference, FFTW Reference
@section Memory Allocator Reference 

@example
#include <fftw.h>

void *(*fftw_malloc_hook) (size_t n);
void (*fftw_free_hook) (void *p);
@end example
@vindex fftw_malloc_hook
@findex fftw_malloc
@ffindex malloc
@vindex fftw_free_hook

Whenever it has to allocate and release memory, FFTW ordinarily calls
@code{malloc} and @code{free}.  
If @code{malloc} fails, FFTW prints an error message and exits.  This
behavior may be undesirable in some applications. Also, special
memory-handling functions may be necessary in certain
environments. Consequently, FFTW provides means by which you can install
your own memory allocator and take whatever error-correcting action you
find appropriate.  The variables @code{fftw_malloc_hook} and
@code{fftw_free_hook} are pointers to functions, and they are normally
@code{NULL}.  If you set those variables to point to other functions,
then FFTW will use your routines instead of @code{malloc} and
@code{free}.  @code{fftw_malloc_hook} must point to a @code{malloc}-like
function, and @code{fftw_free_hook} must point to a @code{free}-like
function.

@c -------------------------------------------------------
@node Thread safety,  , Memory Allocator Reference, FFTW Reference
@section Thread safety

@cindex threads
@cindex thread safety
Users writing multi-threaded programs must concern themselves with the
@dfn{thread safety} of the libraries they use---that is, whether it is
safe to call routines in parallel from multiple threads.  FFTW can be
used in such an environment, but some care must be taken because certain
parts of FFTW use private global variables to share data between calls.
In particular, the plan-creation functions share trigonometric tables
and accumulated @code{wisdom}.  (Users should note that these comments
only apply to programs using shared-memory threads.  Parallelism using
MPI or forked processes involves a separate address-space and global
variables for each process, and is not susceptible to problems of this
sort.)

The central restriction of FFTW is that it is not safe to create
multiple plans in parallel.  You must either create all of your plans
from a single thread, or instead use a semaphore, mutex, or other
mechanism to ensure that different threads don't attempt to create plans
at the same time.  The same restriction also holds for destruction of
plans and importing/forgetting @code{wisdom}.  Once created, a plan may
safely be used in any thread.

The actual transform routines in FFTW (@code{fftw_one}, etcetera) are
re-entrant and thread-safe, so it is fine to call them simultaneously
from multiple threads.  Another question arises, however---is it safe to
use the @emph{same plan} for multiple transforms in parallel?  (It would
be unsafe if, for example, the plan were modified in some way by the
transform.)  We address this question by defining an additional planner
flag, @code{FFTW_THREADSAFE}.
@ctindex FFTW_THREADSAFE
When included in the flags for any of the plan-creation routines,
@code{FFTW_THREADSAFE} guarantees that the resulting plan will be
read-only and safe to use in parallel by multiple threads.

@c ************************************************************
@node Parallel FFTW, Calling FFTW from Fortran, FFTW Reference, Top
@chapter Parallel FFTW

@cindex parallel transform
In this chapter we discuss the use of FFTW in a parallel environment,
documenting the different parallel libraries that we have provided.
(Users calling FFTW from a multi-threaded program should also consult
@ref{Thread safety}.)  The FFTW package currently contains three parallel
transform implementations that leverage the uniprocessor FFTW code:

@itemize @bullet

@item
@cindex threads
The first set of routines utilizes shared-memory threads for parallel
one- and multi-dimensional transforms of both real and complex data.
Any program using FFTW can be trivially modified to use the
multi-threaded routines.  This code can use any common threads
implementation, including POSIX threads.  (POSIX threads are available
on most Unix variants, including Linux.)  These routines are located in
the @code{threads} directory, and are documented in @ref{Multi-threaded
FFTW}.

@item
@cindex MPI
@cindex distributed memory
The @code{mpi} directory contains multi-dimensional transforms
of real and complex data for parallel machines supporting MPI.  It also
includes parallel one-dimensional transforms for complex data.  The main
feature of this code is that it supports distributed-memory transforms,
so it runs on everything from workstation clusters to massively-parallel
supercomputers.  More information on MPI can be found at the
@uref{http://www.mcs.anl.gov/mpi, MPI home page}.  The FFTW MPI routines
are documented in @ref{MPI FFTW}.

@item
@cindex Cilk
We also have an experimental parallel implementation written in Cilk, a
C-like parallel language developed at MIT and currently available for
several SMP platforms.  For more information on Cilk see
@uref{http://supertech.lcs.mit.edu/cilk, the Cilk home page}.  The FFTW
Cilk code can be found in the @code{cilk} directory, with parallelized
one- and multi-dimensional transforms of complex data.  The Cilk FFTW
routines are documented in @code{cilk/README}.

@end itemize

@menu
* Multi-threaded FFTW::         
* MPI FFTW::                    
@end menu

@c ------------------------------------------------------------
@node Multi-threaded FFTW, MPI FFTW, Parallel FFTW, Parallel FFTW
@section Multi-threaded FFTW

@cindex threads
In this section we document the parallel FFTW routines for shared-memory
threads on SMP hardware.  These routines, which support parallel one-
and multi-dimensional transforms of both real and complex data, are the
easiest way to take advantage of multiple processors with FFTW.  They
work just like the corresponding uniprocessor transform routines, except
that they take the number of parallel threads to use as an extra
parameter.  Any program that uses the uniprocessor FFTW can be trivially
modified to use the multi-threaded FFTW.

@menu
* Installation and Supported Hardware/Software::  
* Usage of Multi-threaded FFTW::  
* How Many Threads to Use?::    
* Using Multi-threaded FFTW in a Multi-threaded Program::  
* Tips for Optimal Threading::  
@end menu

@c -------------------------------------------------------
@node Installation and Supported Hardware/Software, Usage of Multi-threaded FFTW, Multi-threaded FFTW, Multi-threaded FFTW
@subsection Installation and Supported Hardware/Software

All of the FFTW threads code is located in the @code{threads}
subdirectory of the FFTW package.  On Unix systems, the FFTW threads
libraries and header files can be automatically configured, compiled,
and installed along with the uniprocessor FFTW libraries simply by
including @code{--enable-threads} in the flags to the @code{configure}
script (@pxref{Installation on Unix}).  (Note also that the threads
routines, when enabled, are automatically tested by the @samp{@code{make
check}} self-tests.)
@fpindex configure

The threads routines require your operating system to have some sort of
shared-memory threads support.  Specifically, the FFTW threads package
works with POSIX threads (available on most Unix variants, including
Linux), Solaris threads, @uref{http://www.be.com,BeOS} threads (tested
on BeOS DR8.2), Mach C threads (reported to work by users), and Win32
threads (reported to work by users).  (There is also untested code to
use MacOS MP threads.)  We also support using
@uref{http://www.openmp.org,OpenMP} or SGI MP compiler directives to
launch threads, enabled by using @code{--with-openmp} or
@code{--with-sgimp} in addition to @code{--enable-threads}.  This is
especially useful if you are employing that sort of directive in your
own code, in order to minimize conflicts.  If you have a shared-memory
machine that uses a different threads API, it should be a simple matter
of programming to include support for it; see the file
@code{fftw_threads-int.h} for more detail.

SMP hardware is not required, although of course you need multiple
processors to get any benefit from the multithreaded transforms.

@c -------------------------------------------------------
@node Usage of Multi-threaded FFTW, How Many Threads to Use?, Installation and Supported Hardware/Software, Multi-threaded FFTW
@subsection Usage of Multi-threaded FFTW

Here, it is assumed that the reader is already familiar with the usage
of the uniprocessor FFTW routines, described elsewhere in this manual.
We only describe what one has to change in order to use the
multi-threaded routines.

First, instead of including @code{<fftw.h>} or @code{<rfftw.h>}, you
should include the files @code{<fftw_threads.h>} or
@code{<rfftw_threads.h>}, respectively.

Second, before calling any FFTW routines, you should call the function:

@example
int fftw_threads_init(void);
@end example
@findex fftw_threads_init

This function, which should only be called once (probably in your
@code{main()} function), performs any one-time initialization required
to use threads on your system.  It returns zero if successful, and a
non-zero value if there was an error (in which case, something is
seriously wrong and you should probably exit the program).

Third, when you want to actually compute the transform, you should use
one of the following transform routines instead of the ordinary FFTW
functions:

@example
fftw_threads(nthreads, plan, howmany, in, istride, 
             idist, out, ostride, odist);
@findex fftw_threads

fftw_threads_one(nthreads, plan, in, out);
@findex fftw_threads_one

fftwnd_threads(nthreads, plan, howmany, in, istride,
               idist, out, ostride, odist);
@findex fftwnd_threads

fftwnd_threads_one(nthreads, plan, in, out);
@findex fftwnd_threads_one

rfftw_threads(nthreads, plan, howmany, in, istride, 
              idist, out, ostride, odist);
@findex rfftw_threads

rfftw_threads_one(nthreads, plan, in, out);
@findex rfftw_threads_one

rfftwnd_threads_real_to_complex(nthreads, plan, howmany, in, 
                                istride, idist, out, ostride, odist);
@findex rfftwnd_threads_real_to_complex

rfftwnd_threads_one_real_to_complex(nthreads, plan, in, out);
@findex rfftwnd_threads_one_real_to_complex

rfftwnd_threads_complex_to_real(nthreads, plan, howmany, in,
                                istride, idist, out, ostride, odist);
@findex rfftwnd_threads_complex_to_real

rfftwnd_threads_one_real_to_complex(nthreads, plan, in, out);
@findex rfftwnd_threads_one_real_to_complex

rfftwnd_threads_one_complex_to_real(nthreads, plan, in, out);
@findex rfftwnd_threads_one_complex_to_real
@end example

All of these routines take exactly the same arguments and have exactly
the same effects as their uniprocessor counterparts (i.e. without the
@samp{@code{_threads}}) @emph{except} that they take one extra
parameter, @code{nthreads} (of type @code{int}), before the normal
parameters.@footnote{There is one exception: when performing
one-dimensional in-place transforms, the @code{out} parameter is always
ignored by the multi-threaded routines, instead of being used as a
workspace if it is non-@code{NULL} as in the uniprocessor routines.  The
multi-threaded routines always allocate their own workspace (the size of
which depends upon the number of threads).}  The @code{nthreads}
parameter specifies the number of threads of execution to use when
performing the transform (actually, the maximum number of threads).
@cindex number of threads

For example, to parallelize a single one-dimensional transform of
complex data, instead of calling the uniprocessor @code{fftw_one(plan,
in, out)}, you would call @code{fftw_threads_one(nthreads, plan, in,
out)}.  Passing an @code{nthreads} of @code{1} means to use only one
thread (the main thread), and is equivalent to calling the uniprocessor
routine.  Passing an @code{nthreads} of @code{2} means that the
transform is potentially parallelized over two threads (and two
processors, if you have them), and so on.

These are the only changes you need to make to your source code.  Calls
to all other FFTW routines (plan creation, destruction, wisdom,
etcetera) are not parallelized and remain the same.  (The same plans and
wisdom are used by both uniprocessor and multi-threaded transforms.)
Your arrays are allocated and formatted in the same way, and so on.

Programs using the parallel complex transforms should be linked with
@code{-lfftw_threads -lfftw -lm} on Unix.  Programs using the parallel
real transforms should be linked with @code{-lrfftw_threads
-lfftw_threads -lrfftw -lfftw -lm}.  You will also need to link with
whatever library is responsible for threads on your system
(e.g. @code{-lpthread} on Linux).
@cindex linking on Unix

@c -------------------------------------------------------
@node How Many Threads to Use?, Using Multi-threaded FFTW in a Multi-threaded Program, Usage of Multi-threaded FFTW, Multi-threaded FFTW
@subsection How Many Threads to Use?

@cindex number of threads
There is a fair amount of overhead involved in spawning and synchronizing
threads, so the optimal number of threads to use depends upon the size
of the transform as well as on the number of processors you have.

As a general rule, you don't want to use more threads than you have
processors.  (Using more threads will work, but there will be extra
overhead with no benefit.)  In fact, if the problem size is too small,
you may want to use fewer threads than you have processors.

You will have to experiment with your system to see what level of
parallelization is best for your problem size.  Useful tools to help you
do this are the test programs that are automatically compiled along with
the threads libraries, @code{fftw_threads_test} and
@code{rfftw_threads_test} (in the @code{threads} subdirectory).  These
@pindex fftw_threads_test
@pindex rfftw_threads_test
take the same arguments as the other FFTW test programs (see
@code{tests/README}), except that they also take the number of threads
to use as a first argument, and report the parallel speedup in speed
tests.  For example,

@example
fftw_threads_test 2 -s 128x128
@end example

will benchmark complex 128x128 transforms using two threads and report
the speedup relative to the uniprocessor transform.
@cindex benchmark

For instance, on a 4-processor 200MHz Pentium Pro system running Linux
2.2.0, we found that the "crossover" point at which 2 threads became
beneficial for complex transforms was about 4k points, while 4 threads
became beneficial at 8k points.

@c -------------------------------------------------------
@node Using Multi-threaded FFTW in a Multi-threaded Program, Tips for Optimal Threading, How Many Threads to Use?, Multi-threaded FFTW
@subsection Using Multi-threaded FFTW in a Multi-threaded Program

@cindex thread safety
It is perfectly possible to use the multi-threaded FFTW routines from a
multi-threaded program (e.g. have multiple threads computing
multi-threaded transforms simultaneously).  If you have the processors,
more power to you!  However, the same restrictions apply as for the
uniprocessor FFTW routines (@pxref{Thread safety}).  In particular, you
should recall that you may not create or destroy plans in parallel.

@c -------------------------------------------------------
@node Tips for Optimal Threading,  , Using Multi-threaded FFTW in a Multi-threaded Program, Multi-threaded FFTW
@subsection Tips for Optimal Threading

Not all transforms are equally well-parallelized by the multi-threaded
FFTW routines.  (This is merely a consequence of laziness on the part of
the implementors, and is not inherent to the algorithms employed.)
Mainly, the limitations are in the parallel one-dimensional transforms.
The things to avoid if you want optimal parallelization are as follows:

@subsection Parallelization deficiencies in one-dimensional transforms

@itemize @bullet

@item
Large prime factors can sometimes parallelize poorly.  Of course, you
should avoid these anyway if you want high performance.

@item
@cindex in-place transform
Single in-place transforms don't parallelize completely.  (Multiple
in-place transforms, i.e. @code{howmany > 1}, are fine.)  Again, you
should avoid these in any case if you want high performance, as they
require transforming to a scratch array and copying back.

@item
Single real-complex (@code{rfftw}) transforms don't parallelize
completely.  This is unfortunate, but parallelizing this correctly would
have involved a lot of extra code (and a much larger library).  You
still get some benefit from additional processors, but if you have a
very large number of processors you will probably be better off using
the parallel complex (@code{fftw}) transforms.  Note that
multi-dimensional real transforms or multiple one-dimensional real
transforms are fine.

@end itemize

@c ------------------------------------------------------------
@node MPI FFTW,  , Multi-threaded FFTW, Parallel FFTW
@section MPI FFTW

@cindex MPI
This section describes the MPI FFTW routines for distributed-memory (and
shared-memory) machines supporting MPI (Message Passing Interface).  The
MPI routines are significantly different from the ordinary FFTW because
the transform data here are @emph{distributed} over multiple processes,
so that each process gets only a portion of the array.
@cindex distributed memory
Currently, multi-dimensional transforms of both real and complex data,
as well as one-dimensional transforms of complex data, are supported.

@menu
* MPI FFTW Installation::       
* Usage of MPI FFTW for Complex Multi-dimensional Transforms::  
* MPI Data Layout::             
* Usage of MPI FFTW for Real Multi-dimensional Transforms::  
* Usage of MPI FFTW for Complex One-dimensional Transforms::  
* MPI Tips::                    
@end menu

@c -------------------------------------------------------
@node MPI FFTW Installation, Usage of MPI FFTW for Complex Multi-dimensional Transforms, MPI FFTW, MPI FFTW
@subsection MPI FFTW Installation

The FFTW MPI library code is all located in the @code{mpi} subdirectoy
of the FFTW package (along with source code for test programs).  On Unix
systems, the FFTW MPI libraries and header files can be automatically
configured, compiled, and installed along with the uniprocessor FFTW
libraries simply by including @code{--enable-mpi} in the flags to the
@code{configure} script (@pxref{Installation on Unix}).
@fpindex configure

The only requirement of the FFTW MPI code is that you have the standard
MPI 1.1 (or later) libraries and header files installed on your system.
A free implementation of MPI is available from
@uref{http://www-unix.mcs.anl.gov/mpi/mpich/,the MPICH home page}.

Previous versions of the FFTW MPI routines have had an unfortunate
tendency to expose bugs in MPI implementations.  The current version has
been largely rewritten, and hopefully avoids some of the problems.  If
you run into difficulties, try passing the optional workspace to
@code{(r)fftwnd_mpi} (see below), as this allows us to use the standard
(and hopefully well-tested) @code{MPI_Alltoall} primitive for
@ffindex MPI_Alltoall
communications.  Please let us know (@email{fftw@@fftw.org})
how things work out.

@pindex fftw_mpi_test
@pindex rfftw_mpi_test
Several test programs are included in the @code{mpi} directory.  The
ones most useful to you are probably the @code{fftw_mpi_test} and
@code{rfftw_mpi_test} programs, which are run just like an ordinary MPI
program and accept the same parameters as the other FFTW test programs
(c.f. @code{tests/README}).  For example, @code{mpirun @i{...params...}
fftw_mpi_test -r 0} will run non-terminating complex-transform
correctness tests of random dimensions.  They can also do performance
benchmarks.

@c -------------------------------------------------------
@node Usage of MPI FFTW for Complex Multi-dimensional Transforms, MPI Data Layout, MPI FFTW Installation, MPI FFTW
@subsection Usage of MPI FFTW for Complex Multi-dimensional Transforms

Usage of the MPI FFTW routines is similar to that of the uniprocessor
FFTW.  We assume that the reader already understands the usage of the
uniprocessor FFTW routines, described elsewhere in this manual.  Some
familiarity with MPI is also helpful.

A typical program performing a complex two-dimensional MPI transform
might look something like:

@example
#include <fftw_mpi.h>

int main(int argc, char **argv)
@{
      const int NX = ..., NY = ...;
      fftwnd_mpi_plan plan;
      fftw_complex *data;

      MPI_Init(&argc,&argv);

      plan = fftw2d_mpi_create_plan(MPI_COMM_WORLD,
                                    NX, NY,
                                    FFTW_FORWARD, FFTW_ESTIMATE);

      ...allocate and initialize data...

      fftwnd_mpi(p, 1, data, NULL, FFTW_NORMAL_ORDER);

      ...

      fftwnd_mpi_destroy_plan(plan);
      MPI_Finalize();
@}
@end example

The calls to @code{MPI_Init} and @code{MPI_Finalize} are required in all
@ffindex MPI_Init
@ffindex MPI_Finalize
MPI programs; see the @uref{http://www.mcs.anl.gov/mpi/,MPI home page}
for more information.  Note that all of your processes run the program
in parallel, as a group; there is no explicit launching of
threads/processes in an MPI program.

@cindex plan
As in the ordinary FFTW, the first thing we do is to create a plan (of
type @code{fftwnd_mpi_plan}), using:

@example
fftwnd_mpi_plan fftw2d_mpi_create_plan(MPI_Comm comm,
                                       int nx, int ny,
                                       fftw_direction dir, int flags);
@end example
@findex fftw2d_mpi_create_plan
@tindex fftwnd_mpi_plan

Except for the first argument, the parameters are identical to those of
@code{fftw2d_create_plan}.  (There are also analogous
@code{fftwnd_mpi_create_plan} and @code{fftw3d_mpi_create_plan}
functions.  Transforms of any rank greater than one are supported.)
@findex fftwnd_mpi_create_plan
@findex fftw3d_mpi_create_plan
The first argument is an MPI @dfn{communicator}, which specifies the
group of processes that are to be involved in the transform; the
standard constant @code{MPI_COMM_WORLD} indicates all available
processes.
@fcindex MPI_COMM_WORLD

Next, one has to allocate and initialize the data.  This is somewhat
tricky, because the transform data is distributed across the processes
involved in the transform.  It is discussed in detail by the next
section (@pxref{MPI Data Layout}).

The actual computation of the transform is performed by the function
@code{fftwnd_mpi}, which differs somewhat from its uniprocessor
equivalent and is described by:

@example
void fftwnd_mpi(fftwnd_mpi_plan p,
                int n_fields,
                fftw_complex *local_data, fftw_complex *work,
                fftwnd_mpi_output_order output_order);
@end example
@findex fftwnd_mpi

There are several things to notice here:

@itemize @bullet

@item
@cindex in-place transform
First of all, all @code{fftw_mpi} transforms are in-place: the output is
in the @code{local_data} parameter, and there is no need to specify
@code{FFTW_IN_PLACE} in the plan flags.

@item
@cindex n_fields
@cindex stride
The MPI transforms also only support a limited subset of the
@code{howmany}/@code{stride}/@code{dist} functionality of the
uniprocessor routines: the @code{n_fields} parameter is equivalent to
@code{howmany=n_fields}, @code{stride=n_fields}, and @code{dist=1}.
(Conceptually, the @code{n_fields} parameter allows you to transform an
array of contiguous vectors, each with length @code{n_fields}.)
@code{n_fields} is @code{1} if you are only transforming a single,
ordinary array.

@item
The @code{work} parameter is an optional workspace.  If it is not
@code{NULL}, it should be exactly the same size as the @code{local_data}
array.  If it is provided, FFTW is able to use the built-in
@code{MPI_Alltoall} primitive for (often) greater efficiency at the
@ffindex MPI_Alltoall
expense of extra storage space.

@item
Finally, the last parameter specifies whether the output data has the
same ordering as the input data (@code{FFTW_NORMAL_ORDER}), or if it is
transposed (@code{FFTW_TRANSPOSED_ORDER}).  Leaving the data transposed
@ctindex FFTW_NORMAL_ORDER
@ctindex FFTW_TRANSPOSED_ORDER
results in significant performance improvements due to a saved
communication step (needed to un-transpose the data).  Specifically, the
first two dimensions of the array are transposed, as is described in
more detail by the next section.

@end itemize

@cindex normalization
The output of @code{fftwnd_mpi} is identical to that of the
corresponding uniprocessor transform.  In particular, you should recall
our conventions for normalization and the sign of the transform
exponent.

The same plan can be used to compute many transforms of the same size.
After you are done with it, you should deallocate it by calling
@code{fftwnd_mpi_destroy_plan}.
@findex fftwnd_mpi_destroy_plan

@cindex blocking
@ffindex MPI_Barrier
@b{Important:} The FFTW MPI routines must be called in the same order by
all processes involved in the transform.  You should assume that they
all are blocking, as if each contained a call to @code{MPI_Barrier}.

Programs using the FFTW MPI routines should be linked with
@code{-lfftw_mpi -lfftw -lm} on Unix, in addition to whatever libraries
are required for MPI.
@cindex linking on Unix

@c -------------------------------------------------------
@node MPI Data Layout, Usage of MPI FFTW for Real Multi-dimensional Transforms, Usage of MPI FFTW for Complex Multi-dimensional Transforms, MPI FFTW
@subsection MPI Data Layout

@cindex distributed memory
@cindex distributed array format
The transform data used by the MPI FFTW routines is @dfn{distributed}: a
distinct portion of it resides with each process involved in the
transform.  This allows the transform to be parallelized, for example,
over a cluster of workstations, each with its own separate memory, so
that you can take advantage of the total memory of all the processors
you are parallelizing over.

In particular, the array is divided according to the rows (first
dimension) of the data: each process gets a subset of the rows of the
@cindex slab decomposition
data.  (This is sometimes called a ``slab decomposition.'')  One
consequence of this is that you can't take advantage of more processors
than you have rows (e.g. @code{64x64x64} matrix can at most use 64
processors).  This isn't usually much of a limitation, however, as each
processor needs a fair amount of data in order for the
parallel-computation benefits to outweight the communications costs.

Below, the first dimension of the data will be referred to as
@samp{@code{x}} and the second dimension as @samp{@code{y}}.

FFTW supplies a routine to tell you exactly how much data resides on the
current process:

@example
void fftwnd_mpi_local_sizes(fftwnd_mpi_plan p,
                            int *local_nx,
                            int *local_x_start,
                            int *local_ny_after_transpose,
                            int *local_y_start_after_transpose,
                            int *total_local_size);
@end example
@findex fftwnd_mpi_local_sizes

Given a plan @code{p}, the other parameters of this routine are set to
values describing the required data layout, described below.

@code{total_local_size} is the number of @code{fftw_complex} elements
that you must allocate for your local data (and workspace, if you
choose).  (This value should, of course, be multiplied by
@code{n_fields} if that parameter to @code{fftwnd_mpi} is not @code{1}.)

The data on the current process has @code{local_nx} rows, starting at
row @code{local_x_start}.  If @code{fftwnd_mpi} is called with
@code{FFTW_TRANSPOSED_ORDER} output, then @code{y} will be the first
dimension of the output, and the local @code{y} extent will be given by
@code{local_ny_after_transpose} and
@code{local_y_start_after_transpose}.  Otherwise, the output has the
same dimensions and layout as the input.

For instance, suppose you want to transform three-dimensional data of
size @code{nx x ny x nz}.  Then, the current process will store a subset
of this data, of size @code{local_nx x ny x nz}, where the @code{x}
indices correspond to the range @code{local_x_start} to
@code{local_x_start+local_nx-1} in the ``real'' (i.e. logical) array.
If @code{fftwnd_mpi} is called with @code{FFTW_TRANSPOSED_ORDER} output,
@ctindex FFTW_TRANSPOSED_ORDER
then the result will be a @code{ny x nx x nz} array, of which a
@code{local_ny_after_transpose x nx x nz} subset is stored on the
current process (corresponding to @code{y} values starting at
@code{local_y_start_after_transpose}).

The following is an example of allocating such a three-dimensional array
array (@code{local_data}) before the transform and initializing it to
some function @code{f(x,y,z)}:

@example
        fftwnd_mpi_local_sizes(plan, &local_nx, &local_x_start,
                               &local_ny_after_transpose,
                               &local_y_start_after_transpose,
                               &total_local_size);

        local_data = (fftw_complex*) malloc(sizeof(fftw_complex) *
                                            total_local_size);

        for (x = 0; x < local_nx; ++x)
                for (y = 0; y < ny; ++y)
                        for (z = 0; z < nz; ++z)
                                local_data[(x*ny + y)*nz + z]
                                        = f(x + local_x_start, y, z);
@end example

Some important things to remember:

@itemize @bullet

@item
Although the local data is of dimensions @code{local_nx x ny x nz} in
the above example, do @emph{not} allocate the array to be of size
@code{local_nx*ny*nz}.  Use @code{total_local_size} instead.

@item
The amount of data on each process will not necessarily be the same; in
fact, @code{local_nx} may even be zero for some processes.  (For
example, suppose you are doing a @code{6x6} transform on four
processors.  There is no way to effectively use the fourth processor in
a slab decomposition, so we leave it empty.  Proof left as an exercise
for the reader.)

@item
@cindex row-major
All arrays are, of course, in row-major order (@pxref{Multi-dimensional
Array Format}).

@item
If you want to compute the inverse transform of the output of
@code{fftwnd_mpi}, the dimensions of the inverse transform are given by
the dimensions of the output of the forward transform.  For example, if
you are using @code{FFTW_TRANSPOSED_ORDER} output in the above example,
then the inverse plan should be created with dimensions @code{ny x nx x
nz}.

@item
The data layout only depends upon the dimensions of the array, not on
the plan, so you are guaranteed that different plans for the same size
(or inverse plans) will use the same (consistent) data layouts.

@end itemize

@c -------------------------------------------------------
@node Usage of MPI FFTW for Real Multi-dimensional Transforms, Usage of MPI FFTW for Complex One-dimensional Transforms, MPI Data Layout, MPI FFTW
@subsection Usage of MPI FFTW for Real Multi-dimensional Transforms

MPI transforms specialized for real data are also available, similiar to
the uniprocessor @code{rfftwnd} transforms.  Just as in the uniprocessor
case, the real-data MPI functions gain roughly a factor of two in speed
(and save a factor of two in space) at the expense of more complicated
data formats in the calling program.  Before reading this section, you
should definitely understand how to call the uniprocessor @code{rfftwnd}
functions and also the complex MPI FFTW functions.

The following is an example of a program using @code{rfftwnd_mpi}.  It
computes the size @code{nx x ny x nz} transform of a real function
@code{f(x,y,z)}, multiplies the imaginary part by @code{2} for fun, then
computes the inverse transform.  (We'll also use
@code{FFTW_TRANSPOSED_ORDER} output for the transform, and additionally
supply the optional workspace parameter to @code{rfftwnd_mpi}, just to
add a little spice.)

@example
#include <rfftw_mpi.h>

int main(int argc, char **argv)
@{
     const int nx = ..., ny = ..., nz = ...;
     int local_nx, local_x_start, local_ny_after_transpose,
         local_y_start_after_transpose, total_local_size;
     int x, y, z;
     rfftwnd_mpi_plan plan, iplan;
     fftw_real *data, *work;
     fftw_complex *cdata;

     MPI_Init(&argc,&argv);

     /* create the forward and backward plans: */
     plan = rfftw3d_mpi_create_plan(MPI_COMM_WORLD,
                                    nx, ny, nz,
                                    FFTW_REAL_TO_COMPLEX,
                                    FFTW_ESTIMATE);
@findex rfftw3d_mpi_create_plan
     iplan = rfftw3d_mpi_create_plan(MPI_COMM_WORLD,
      /* dim.'s of REAL data --> */  nx, ny, nz,
                                     FFTW_COMPLEX_TO_REAL,
                                     FFTW_ESTIMATE);

     rfftwnd_mpi_local_sizes(plan, &local_nx, &local_x_start,
                            &local_ny_after_transpose,
                            &local_y_start_after_transpose,
                            &total_local_size);
@findex rfftwnd_mpi_local_sizes

     data = (fftw_real*) malloc(sizeof(fftw_real) * total_local_size);

     /* workspace is the same size as the data: */
     work = (fftw_real*) malloc(sizeof(fftw_real) * total_local_size);

     /* initialize data to f(x,y,z): */
     for (x = 0; x < local_nx; ++x)
             for (y = 0; y < ny; ++y)
                     for (z = 0; z < nz; ++z)
                             data[(x*ny + y) * (2*(nz/2+1)) + z]
                                     = f(x + local_x_start, y, z);

     /* Now, compute the forward transform: */
     rfftwnd_mpi(plan, 1, data, work, FFTW_TRANSPOSED_ORDER);
@findex rfftwnd_mpi

     /* the data is now complex, so typecast a pointer: */
     cdata = (fftw_complex*) data;
     
     /* multiply imaginary part by 2, for fun:
        (note that the data is transposed) */
     for (y = 0; y < local_ny_after_transpose; ++y)
             for (x = 0; x < nx; ++x)
                     for (z = 0; z < (nz/2+1); ++z)
                             cdata[(y*nx + x) * (nz/2+1) + z].im
                                     *= 2.0;

     /* Finally, compute the inverse transform; the result
        is transposed back to the original data layout: */
     rfftwnd_mpi(iplan, 1, data, work, FFTW_TRANSPOSED_ORDER);

     free(data);
     free(work);
     rfftwnd_mpi_destroy_plan(plan);
@findex rfftwnd_mpi_destroy_plan
     rfftwnd_mpi_destroy_plan(iplan);
     MPI_Finalize();
@}
@end example

There's a lot of stuff in this example, but it's all just what you would
have guessed, right?  We replaced all the @code{fftwnd_mpi*} functions
by @code{rfftwnd_mpi*}, but otherwise the parameters were pretty much
the same.  The data layout distributed among the processes just like for
the complex transforms (@pxref{MPI Data Layout}), but in addition the
final dimension is padded just like it is for the uniprocessor in-place
real transforms (@pxref{Array Dimensions for Real Multi-dimensional
Transforms}).
@cindex padding
In particular, the @code{z} dimension of the real input data is padded
to a size @code{2*(nz/2+1)}, and after the transform it contains
@code{nz/2+1} complex values.
@cindex distributed array format
@cindex rfftwnd array format

Some other important things to know about the real MPI transforms:

@itemize @bullet

@item
As for the uniprocessor @code{rfftwnd_create_plan}, the dimensions
passed for the @code{FFTW_COMPLEX_TO_REAL} plan are those of the
@emph{real} data.  In particular, even when @code{FFTW_TRANSPOSED_ORDER}
@ctindex FFTW_COMPLEX_TO_REAL
@ctindex FFTW_TRANSPOSED_ORDER
is used as in this case, the dimensions are those of the (untransposed)
real output, not the (transposed) complex input.  (For the complex MPI
transforms, on the other hand, the dimensions are always those of the
input array.)

@item
The output ordering of the transform (@code{FFTW_TRANSPOSED_ORDER} or
@code{FFTW_TRANSPOSED_ORDER}) @emph{must} be the same for both forward
and backward transforms.  (This is not required in the complex case.)

@item
@code{total_local_size} is the required size in @code{fftw_real} values,
not @code{fftw_complex} values as it is for the complex transforms.

@item
@code{local_ny_after_transpose} and @code{local_y_start_after_transpose}
describe the portion of the array after the transform; that is, they are
indices in the complex array for an @code{FFTW_REAL_TO_COMPLEX} transform
and in the real array for an @code{FFTW_COMPLEX_TO_REAL} transform.

@item
@code{rfftwnd_mpi} always expects @code{fftw_real*} array arguments, but
of course these pointers can refer to either real or complex arrays,
depending upon which side of the transform you are on.  Just as for
in-place uniprocessor real transforms (and also in the example above),
this is most easily handled by typecasting to a complex pointer when
handling the complex data.

@item
As with the complex transforms, there are also
@code{rfftwnd_create_plan} and @code{rfftw2d_create_plan} functions, and
any rank greater than one is supported.
@findex rfftwnd_create_plan
@findex rfftw2d_create_plan

@end itemize

Programs using the MPI FFTW real transforms should link with
@code{-lrfftw_mpi -lfftw_mpi -lrfftw -lfftw -lm} on Unix.
@cindex linking on Unix

@c -------------------------------------------------------
@node Usage of MPI FFTW for Complex One-dimensional Transforms, MPI Tips, Usage of MPI FFTW for Real Multi-dimensional Transforms, MPI FFTW
@subsection Usage of MPI FFTW for Complex One-dimensional Transforms

The MPI FFTW also includes routines for parallel one-dimensional
transforms of complex data (only).  Although the speedup is generally
worse than it is for the multi-dimensional routines,@footnote{The 1D
transforms require much more communication.  All the communication in
our FFT routines takes the form of an all-to-all communication: the
multi-dimensional transforms require two all-to-all communications (or
one, if you use @code{FFTW_TRANSPOSED_ORDER}), while the one-dimensional
transforms require @emph{three} (or two, if you use scrambled input or
output).} these distributed-memory one-dimensional transforms are
especially useful for performing one-dimensional transforms that don't
fit into the memory of a single machine.

The usage of these routines is straightforward, and is similar to that
of the multi-dimensional MPI transform functions.  You first include the
header @code{<fftw_mpi.h>} and then create a plan by calling:

@example
fftw_mpi_plan fftw_mpi_create_plan(MPI_Comm comm, int n, 
                                   fftw_direction dir, int flags);
@end example
@findex fftw_mpi_create_plan
@tindex fftw_mpi_plan

The last three arguments are the same as for @code{fftw_create_plan}
(except that all MPI transforms are automatically @code{FFTW_IN_PLACE}).
The first argument specifies the group of processes you are using, and
is usually @code{MPI_COMM_WORLD} (all processes).
@fcindex MPI_COMM_WORLD
A plan can be used for many transforms of the same size, and is
destroyed when you are done with it by calling
@code{fftw_mpi_destroy_plan(plan)}.
@findex fftw_mpi_destroy_plan

If you don't care about the ordering of the input or output data of the
transform, you can include @code{FFTW_SCRAMBLED_INPUT} and/or
@code{FFTW_SCRAMBLED_OUTPUT} in the @code{flags}.
@ctindex FFTW_SCRAMBLED_INPUT
@ctindex FFTW_SCRAMBLED_OUTPUT
@cindex flags
These save some communications at the expense of having the input and/or
output reordered in an undocumented way.  For example, if you are
performing an FFT-based convolution, you might use
@code{FFTW_SCRAMBLED_OUTPUT} for the forward transform and
@code{FFTW_SCRAMBLED_INPUT} for the inverse transform.

The transform itself is computed by:

@example
void fftw_mpi(fftw_mpi_plan p, int n_fields,
              fftw_complex *local_data, fftw_complex *work);
@end example
@findex fftw_mpi

@cindex n_fields
@code{n_fields}, as in @code{fftwnd_mpi}, is equivalent to
@code{howmany=n_fields}, @code{stride=n_fields}, and @code{dist=1}, and
should be @code{1} when you are computing the transform of a single
array.  @code{local_data} contains the portion of the array local to the
current process, described below.  @code{work} is either @code{NULL} or
an array exactly the same size as @code{local_data}; in the latter case,
FFTW can use the @code{MPI_Alltoall} communications primitive which is
(usually) faster at the expense of extra storage.  Upon return,
@code{local_data} contains the portion of the output local to the
current process (see below).
@ffindex MPI_Alltoall

@cindex distributed array format
To find out what portion of the array is stored local to the current
process, you call the following routine:

@example
void fftw_mpi_local_sizes(fftw_mpi_plan p,
                          int *local_n, int *local_start,
                          int *local_n_after_transform,
                          int *local_start_after_transform,
                          int *total_local_size);
@end example
@findex fftw_mpi_local_sizes

@code{total_local_size} is the number of @code{fftw_complex} elements
you should actually allocate for @code{local_data} (and @code{work}).
@code{local_n} and @code{local_start} indicate that the current process
stores @code{local_n} elements corresponding to the indices
@code{local_start} to @code{local_start+local_n-1} in the ``real''
array.  @emph{After the transform, the process may store a different
portion of the array.}  The portion of the data stored on the process
after the transform is given by @code{local_n_after_transform} and
@code{local_start_after_transform}.  This data is exactly the same as a
contiguous segment of the corresponding uniprocessor transform output
(i.e. an in-order sequence of sequential frequency bins).

Note that, if you compute both a forward and a backward transform of the
same size, the local sizes are guaranteed to be consistent.  That is,
the local size after the forward transform will be the same as the local
size before the backward transform, and vice versa.

Programs using the FFTW MPI routines should be linked with
@code{-lfftw_mpi -lfftw -lm} on Unix, in addition to whatever libraries
are required for MPI.
@cindex linking on Unix

@c -------------------------------------------------------
@node MPI Tips,  , Usage of MPI FFTW for Complex One-dimensional Transforms, MPI FFTW
@subsection MPI Tips

There are several things you should consider in order to get the best
performance out of the MPI FFTW routines.

@cindex load-balancing
First, if possible, the first and second dimensions of your data should
be divisible by the number of processes you are using.  (If only one can
be divisible, then you should choose the first dimension.)  This allows
the computational load to be spread evenly among the processes, and also
reduces the communications complexity and overhead.  In the
one-dimensional transform case, the size of the transform should ideally
be divisible by the @emph{square} of the number of processors.

@ctindex FFTW_TRANSPOSED_ORDER
Second, you should consider using the @code{FFTW_TRANSPOSED_ORDER}
output format if it is not too burdensome.  The speed gains from
communications savings are usually substantial.

Third, you should consider allocating a workspace for
@code{(r)fftw(nd)_mpi}, as this can often
(but not always) improve performance (at the cost of extra storage).

Fourth, you should experiment with the best number of processors to use
for your problem.  (There comes a point of diminishing returns, when the
communications costs outweigh the computational benefits.@footnote{An
FFT is particularly hard on communications systems, as it requires an
@dfn{all-to-all} communication, which is more or less the worst possible
case.})  The @code{fftw_mpi_test} program can output helpful performance
benchmarks.
@pindex fftw_mpi_test
@cindex benchmark
It accepts the same parameters as the uniprocessor test programs
(c.f. @code{tests/README}) and is run like an ordinary MPI program.  For
example, @code{mpirun -np 4 fftw_mpi_test -s 128x128x128} will benchmark
a @code{128x128x128} transform on four processors, reporting timings and
parallel speedups for all variants of @code{fftwnd_mpi} (transposed,
with workspace, etcetera).  (Note also that there is the
@code{rfftw_mpi_test} program for the real transforms.)
@pindex rfftw_mpi_test


@c ************************************************************
@node Calling FFTW from Fortran, Installation and Customization, Parallel FFTW, Top
@chapter Calling FFTW from Fortran

@cindex Fortran-callable wrappers
The standard FFTW libraries include special wrapper functions that allow
Fortran programs to call FFTW subroutines.  This chapter describes how
those functions may be employed to use FFTW from Fortran.  We assume
here that the reader is already familiar with the usage of FFTW in C, as
described elsewhere in this manual.

In general, it is not possible to call C functions directly from
Fortran, due to Fortran's inability to pass arguments by value and also
because Fortran compilers typically expect identifiers to be mangled
@cindex compiler
somehow for linking.  However, if C functions are written in a special
way, they @emph{are} callable from Fortran, and we have employed this
technique to create Fortran-callable ``wrapper'' functions around the
main FFTW routines.  These wrapper functions are included in the FFTW
libraries by default, unless a Fortran compiler isn't found on your
system or @code{--disable-fortran} is included in the @code{configure}
flags.

As a result, calling FFTW from Fortran requires little more than
appending @samp{@code{_f77}} to the function names and then linking
normally with the FFTW libraries.  There are a few wrinkles, however, as
we shall discuss below.

@menu
* Wrapper Routines::            
* FFTW Constants in Fortran::   
* Fortran Examples::            
@end menu

@c -------------------------------------------------------
@node Wrapper Routines, FFTW Constants in Fortran, Calling FFTW from Fortran, Calling FFTW from Fortran
@section Wrapper Routines

All of the uniprocessor and multi-threaded transform routines have
Fortran-callable wrappers, except for the wisdom import/export functions
(since it is not possible to exchange string and file arguments portably
with Fortran) and the specific planner routines (@pxref{Discussion on
Specific Plans}).  The name of the wrapper routine is the same as that
of the corresponding C routine, but with
@code{fftw/fftwnd/rfftw/rfftwnd} replaced by
@code{fftw_f77/fftwnd_f77/rfftw_f77/rfftwnd_f77}.  For example, in
Fortran, instead of calling @code{fftw_one} you would call
@code{fftw_f77_one}.@footnote{Technically, Fortran 77 identifiers are
not allowed to have more than 6 characters, nor may they contain
underscores.  Any compiler that enforces this limitation doesn't deserve
to link to FFTW.}
@findex fftw_f77_one
For the most part, all of the arguments to the functions are the same,
with the following exceptions:

@itemize @bullet

@item
@code{plan} variables (what would be of type @code{fftw_plan},
@code{rfftwnd_plan}, etcetera, in C), must be declared as a type that is
the same size as a pointer (address) on your machine.  (Fortran has no
generic pointer type.)  The Fortran @code{integer} type is usually the
same size as a pointer, but you need to be wary (especially on 64-bit
machines).  (You could also use @code{integer*4} on a 32-bit machine and
@code{integer*8} on a 64-bit machine.)  Ugh.  (@code{g77} has a special
type, @code{integer(kind=7)}, that is defined to be the same size as a
pointer.)

@item
Any function that returns a value (e.g. @code{fftw_create_plan}) is
converted into a subroutine.  The return value is converted into an
additional (first) parameter of the wrapper subroutine.  (The reason for
this is that some Fortran implementations seem to have trouble with C
function return values.)

@item
@cindex in-place transform
When performing one-dimensional @code{FFTW_IN_PLACE} transforms, you
don't have the option of passing @code{NULL} for the @code{out} argument
(since there is no way to pass @code{NULL} from Fortran).  Therefore,
when performing such transforms, you @emph{must} allocate and pass a
contiguous scratch array of the same size as the transform.  Note that
for in-place multi-dimensional (@code{(r)fftwnd}) transforms, the
@code{out} argument is ignored, so you can pass anything for that
parameter.

@item
@cindex column-major
The wrapper routines expect multi-dimensional arrays to be in
column-major order, which is the ordinary format of Fortran arrays.
They do this transparently and costlessly simply by reversing the order
of the dimensions passed to FFTW, but this has one important consequence
for multi-dimensional real-complex transforms, discussed below.

@end itemize

@cindex floating-point precision
In general, you should take care to use Fortran data types that
correspond to (i.e. are the same size as) the C types used by FFTW.  If
your C and Fortran compilers are made by the same vendor, the
correspondence is usually straightforward (i.e. @code{integer}
corresponds to @code{int}, @code{real} corresponds to @code{float},
etcetera).  Such simple correspondences are assumed in the examples
below.  The examples also assume that FFTW was compiled in
double precision (the default).

@c -------------------------------------------------------
@node  FFTW Constants in Fortran, Fortran Examples, Wrapper Routines, Calling FFTW from Fortran
@section FFTW Constants in Fortran

When creating plans in FFTW, a number of constants are used to specify
options, such as @code{FFTW_FORWARD} or @code{FFTW_USE_WISDOM}.  The
same constants must be used with the wrapper routines, but of course the
C header files where the constants are defined can't be incorporated
directly into Fortran code.

Instead, we have placed Fortran equivalents of the FFTW constant
definitions in the file @code{fortran/fftw_f77.i} of the FFTW package.
If your Fortran compiler supports a preprocessor, you can use that to
incorporate this file into your code whenever you need to call FFTW.
Otherwise, you will have to paste the constant definitions in directly.
They are:

@example
      integer FFTW_FORWARD,FFTW_BACKWARD
      parameter (FFTW_FORWARD=-1,FFTW_BACKWARD=1)

      integer FFTW_REAL_TO_COMPLEX,FFTW_COMPLEX_TO_REAL
      parameter (FFTW_REAL_TO_COMPLEX=-1,FFTW_COMPLEX_TO_REAL=1)

      integer FFTW_ESTIMATE,FFTW_MEASURE
      parameter (FFTW_ESTIMATE=0,FFTW_MEASURE=1)

      integer FFTW_OUT_OF_PLACE,FFTW_IN_PLACE,FFTW_USE_WISDOM
      parameter (FFTW_OUT_OF_PLACE=0)
      parameter (FFTW_IN_PLACE=8,FFTW_USE_WISDOM=16)

      integer FFTW_THREADSAFE
      parameter (FFTW_THREADSAFE=128)
@end example

@cindex flags
In C, you combine different flags (like @code{FFTW_USE_WISDOM} and
@code{FFTW_MEASURE}) using the @samp{@code{|}} operator; in Fortran you
should just use @samp{@code{+}}.

@c -------------------------------------------------------
@node Fortran Examples,  , FFTW Constants in Fortran, Calling FFTW from Fortran
@section Fortran Examples

In C you might have something like the following to transform a
one-dimensional complex array:

@example
        fftw_complex in[N], *out[N];
        fftw_plan plan;

        plan = fftw_create_plan(N,FFTW_FORWARD,FFTW_ESTIMATE);
        fftw_one(plan,in,out);
        fftw_destroy_plan(plan);
@end example

In Fortran, you use the following to accomplish the same thing:

@example
        double complex in, out
        dimension in(N), out(N)
        integer plan

        call fftw_f77_create_plan(plan,N,FFTW_FORWARD,FFTW_ESTIMATE)
        call fftw_f77_one(plan,in,out)
        call fftw_f77_destroy_plan(plan)
@end example
@findex fftw_f77_create_plan
@findex fftw_f77_one
@findex fftw_f77_destroy_plan

Notice how all routines are called as Fortran subroutines, and the plan
is returned via the first argument to @code{fftw_f77_create_plan}.
@emph{Important:} these examples assume that @code{integer} is the same
size as a pointer, and may need modification on a 64-bit machine.
@xref{Wrapper Routines}, above.  To do the same thing, but using 8
threads in parallel (@pxref{Multi-threaded FFTW}), you would simply
replace the call to @code{fftw_f77_one} with:

@example
        call fftw_f77_threads_one(8,plan,in,out)
@end example
@findex fftw_f77_threads_one

To transform a three-dimensional array in-place with C, you might do:

@example
        fftw_complex arr[L][M][N];
        fftwnd_plan plan;
        int n[3] = @{L,M,N@};

        plan = fftwnd_create_plan(3,n,FFTW_FORWARD,
                                  FFTW_ESTIMATE | FFTW_IN_PLACE);
        fftwnd_one(plan, arr, 0);
        fftwnd_destroy_plan(plan);
@end example

In Fortran, you would use this instead:

@example
        double complex arr
        dimension arr(L,M,N)
        integer n
        dimension n(3)
        integer plan

        n(1) = L
        n(2) = M
        n(3) = N
        call fftwnd_f77_create_plan(plan,3,n,FFTW_FORWARD,
       +                            FFTW_ESTIMATE + FFTW_IN_PLACE)
        call fftwnd_f77_one(plan, arr, 0)
        call fftwnd_f77_destroy_plan(plan)
@end example
@findex fftwnd_f77_create_plan
@findex fftwnd_f77_one
@findex fftwnd_f77_destroy_plan

Instead of calling @code{fftwnd_f77_create_plan(plan,3,n,...)}, we could
also have called @code{fftw3d_f77_create_plan(plan,L,M,N,...)}.
@findex fftw3d_f77_create_plan

Note that we pass the array dimensions in the "natural" order; also
note that the last argument to @code{fftwnd_f77} is ignored since the
transform is @code{FFTW_IN_PLACE}.

To transform a one-dimensional real array in Fortran, you might do:

@example
        double precision in, out
        dimension in(N), out(N)
        integer plan

        call rfftw_f77_create_plan(plan,N,FFTW_REAL_TO_COMPLEX,
       +                           FFTW_ESTIMATE)
        call rfftw_f77_one(plan,in,out)
        call rfftw_f77_destroy_plan(plan)
@end example
@findex rfftw_f77_create_plan
@findex rfftw_f77_one
@findex rfftw_f77_destroy_plan

To transform a two-dimensional real array, out of place, you might use
the following:

@example
        double precision in
        double complex out
        dimension in(M,N), out(M/2 + 1, N)
        integer plan

        call rfftw2d_f77_create_plan(plan,M,N,FFTW_REAL_TO_COMPLEX,
       +                             FFTW_ESTIMATE)
        call rfftwnd_f77_one_real_to_complex(plan, in, out)
        call rfftwnd_f77_destroy_plan(plan)
@end example
@findex rfftw2d_f77_create_plan
@findex rfftwnd_f77_one_real_to_complex
@findex rfftwnd_f77_destroy_plan

@b{Important:} Notice that it is the @emph{first} dimension of the
complex output array that is cut in half in Fortran, rather than the
last dimension as in C.  This is a consequence of the wrapper routines
reversing the order of the array dimensions passed to FFTW so that the
Fortran program can use its ordinary column-major order.
@cindex column-major
@cindex rfftwnd array format


@c ************************************************************
@node Installation and Customization, Acknowledgments, Calling FFTW from Fortran, Top
@chapter Installation and Customization

This chapter describes the installation and customization of FFTW, the
latest version of which may be downloaded from
@uref{http://www.fftw.org, the FFTW home page}.

As distributed, FFTW makes very few assumptions about your system.  All
you need is an ANSI C compiler (@code{gcc} is fine, although
vendor-provided compilers often produce faster code).
@cindex compiler
However, installation of FFTW is somewhat simpler if you have a Unix or
a GNU system, such as Linux.  In this chapter, we first describe the
installation of FFTW on Unix and non-Unix systems.  We then describe how
you can customize FFTW to achieve better performance.  Specifically, you
can I) enable @code{gcc}/x86-specific hacks that improve performance on
Pentia and PentiumPro's; II) adapt FFTW to use the high-resolution clock
of your machine, if any; III) produce code (@emph{codelets}) to support
fast transforms of sizes that are not supported efficiently by the
standard FFTW distribution.
@cindex installation

@menu
* Installation on Unix::        
* Installation on non-Unix Systems::  
* Installing FFTW in both single and double precision::  
* gcc and Pentium hacks::  
* Customizing the timer::       
* Generating your own code::    
@end menu

@node Installation on Unix, Installation on non-Unix Systems, Installation and Customization, Installation and Customization
@section Installation on Unix

FFTW comes with a @code{configure} program in the GNU style.
Installation can be as simple as:
@fpindex configure

@example
./configure
make
make install
@end example

This will build the uniprocessor complex and real transform libraries
along with the test programs.  We strongly recommend that you use GNU
@code{make} if it is available; on some systems it is called
@code{gmake}.  The ``@code{make install}'' command installs the fftw and
rfftw libraries in standard places, and typically requires root
privileges (unless you specify a different install directory with the
@code{--prefix} flag to @code{configure}).  You can also type
``@code{make check}'' to put the FFTW test programs through their paces.
If you have problems during configuration or compilation, you may want
to run ``@code{make distclean}'' before trying again; this ensures that
you don't have any stale files left over from previous compilation
attempts.

The @code{configure} script knows good @code{CFLAGS} (C compiler flags)
@cindex compiler flags
for a few systems.  If your system is not known, the @code{configure}
script will print out a warning.  @footnote{Each version of @code{cc}
seems to have its own magic incantation to get the fastest code most of
the time---you'd think that people would have agreed upon some
convention, e.g. "@code{-Omax}", by now.}  In this case, you can compile
FFTW with the command
@example
make CFLAGS="<write your CFLAGS here>"
@end example
If you do find an optimal set of @code{CFLAGS} for your system, please
let us know what they are (along with the output of @code{config.guess})
so that we can include them in future releases.

The @code{configure} program supports all the standard flags defined by
the GNU Coding Standards; see the @code{INSTALL} file in FFTW or
@uref{http://www.gnu.org/prep/standards_toc.html, the GNU web page}.
Note especially @code{--help} to list all flags and
@code{--enable-shared} to create shared, rather than static, libraries.
@code{configure} also accepts a few FFTW-specific flags, particularly:

@itemize @bullet

@item
@cindex floating-point precision
@code{--enable-float} Produces a single-precision version of FFTW
(@code{float}) instead of the default double-precision (@code{double}).
@xref{Installing FFTW in both single and double precision}.

@item
@code{--enable-type-prefix} Adds a @samp{d} or @samp{s} prefix to all
installed libraries and header files to indicate the floating-point
precision.  @xref{Installing FFTW in both single and double
precision}.  (@code{--enable-type-prefix=<prefix>} lets you add an
arbitrary prefix.)  By default, no prefix is used.

@item
@cindex threads
@code{--enable-threads} Enables compilation and installation of the FFTW
threads library (@pxref{Multi-threaded FFTW}), which provides a
simple interface to parallel transforms for SMP systems.  (By default,
the threads routines are not compiled.)

@item
@code{--with-openmp}, @code{--with-sgimp}
In conjunction with @code{--enable-threads}, causes the multi-threaded
FFTW library to use OpenMP or SGI MP compiler directives in order to
induce parallelism, rather than spawning its own threads directly.
(Useful especially for programs already employing such directives, in
order to minimize conflicts between different parallelization
mechanisms.)

@item
@cindex MPI
@code{--enable-mpi} Enables compilation and installation of the FFTW MPI
library (@pxref{MPI FFTW}), which provides parallel transforms for
distributed-memory systems with MPI.  (By default, the MPI routines are
not compiled.)

@item
@cindex Fortran-callable wrappers
@code{--disable-fortran} Disables inclusion of Fortran-callable wrapper
routines (@pxref{Calling FFTW from Fortran}) in the standard FFTW
libraries.  These wrapper routines increase the library size by only a
negligible amount, so they are included by default as long as the
@code{configure} script finds a Fortran compiler on your system.

@item
@code{--with-gcc} Enables the use of @code{gcc}.  By default, FFTW uses
the vendor-supplied @code{cc} compiler if present.  Unfortunately,
@code{gcc} produces slower code than @code{cc} on many systems.

@item
@code{--enable-i386-hacks}  @xref{gcc and Pentium hacks}, below.

@item
@code{--enable-pentium-timer}  @xref{gcc and Pentium hacks}, below.

@end itemize

To force @code{configure} to use a particular C compiler (instead of the
@cindex compiler
default, usually @code{cc}), set the environment variable @code{CC} to
the name of the desired compiler before running @code{configure}; you
may also need to set the flags via the variable @code{CFLAGS}.
@cindex compiler flags

@node Installation on non-Unix Systems, Installing FFTW in both single and double precision, Installation on Unix, Installation and Customization
@section Installation on non-Unix Systems

It is quite straightforward to install FFTW even on non-Unix systems
lacking the niceties of the @code{configure} script.  The FFTW Home Page
may include some FFTW packages preconfigured for particular
systems/compilers, and also contains installation notes sent in by
@cindex compiler
users.  All you really need to do, though, is to compile all of the
@code{.c} files in the appropriate directories of the FFTW package.
(You needn't worry about the many extraneous files lying around.)

For the complex transforms, compile all of the @code{.c} files in the
@code{fftw} directory and link them into a library.  Similarly, for the
real transforms, compile all of the @code{.c} files in the @code{rfftw}
directory into a library.  Note that these sources @code{#include}
various files in the @code{fftw} and @code{rfftw} directories, so you
may need to set up the @code{#include} paths for your compiler
appropriately.  Be sure to enable the highest-possible level of
optimization in your compiler.

@cindex floating-point precision
By default, FFTW is compiled for double-precision transforms.  To work
in single precision rather than double precision, @code{#define} the
symbol @code{FFTW_ENABLE_FLOAT} in @code{fftw.h} (in the @code{fftw}
directory) and (re)compile FFTW.

These libraries should be linked with any program that uses the
corresponding transforms.  The required header files, @code{fftw.h} and
@code{rfftw.h}, are located in the @code{fftw} and @code{rfftw}
directories respectively; you may want to put them with the libraries,
or wherever header files normally go on your system.

FFTW includes test programs, @code{fftw_test} and @code{rfftw_test}, in
@pindex fftw_test
@pindex rfftw_test
the @code{tests} directory.  These are compiled and linked like any
program using FFTW, except that they use additional header files located
in the @code{fftw} and @code{rfftw} directories, so you will need to set
your compiler @code{#include} paths appropriately.  @code{fftw_test} is
compiled from @code{fftw_test.c} and @code{test_main.c}, while
@code{rfftw_test} is compiled from @code{rfftw_test.c} and
@code{test_main.c}.  When you run these programs, you will be prompted
interactively for various possible tests to perform; see also
@code{tests/README} for more information.

@node Installing FFTW in both single and double precision, gcc and Pentium hacks, Installation on non-Unix Systems, Installation and Customization
@section Installing FFTW in both single and double precision

@cindex floating-point precision
It is often useful to install both single- and double-precision versions
of the FFTW libraries on the same machine, and we provide a convenient
mechanism for achieving this on Unix systems.

@fpindex configure
When the @code{--enable-type-prefix} option of configure is used, the
FFTW libraries and header files are installed with a prefix of @samp{d}
or @samp{s}, depending upon whether you compiled in double or single
precision.  Then, instead of linking your program with @code{-lrfftw
-lfftw}, for example, you would link with @code{-ldrfftw -ldfftw} to use
the double-precision version or with @code{-lsrfftw -lsfftw} to use the
single-precision version.  Also, you would @code{#include}
@code{<drfftw.h>} or @code{<srfftw.h>} instead of @code{<rfftw.h>}, and
so on.

@emph{The names of FFTW functions, data types, and constants remain
unchanged!}  You still call, for instance, @code{fftw_one} and not
@code{dfftw_one}.  Only the names of header files and libraries are
modified.  One consequence of this is that @emph{you @b{cannot} use both
the single- and double-precision FFTW libraries in the same program,
simultaneously,} as the function names would conflict.

So, to install both the single- and double-precision libraries on the
same machine, you would do:

@example
./configure --enable-type-prefix @i{[ other options ]}
make
make install
make clean
./configure --enable-float --enable-type-prefix @i{[ other options ]}
make
make install
@end example

@node gcc and Pentium hacks, Customizing the timer, Installing FFTW in both single and double precision, Installation and Customization
@section @code{gcc} and Pentium hacks
@cindex Pentium hack
The @code{configure} option @code{--enable-i386-hacks} enables specific
optimizations for the Pentium and later x86 CPUs under gcc, which can
significantly improve performance of double-precision transforms.
Specifically, we have tested these hacks on Linux with @code{gcc} 2.[789]
and versions of @code{egcs} since 1.0.3.  These optimizations affect
only the performance and not the correctness of FFTW (i.e. it is always
safe to try them out).

These hacks provide a workaround to the incorrect alignment of local
@code{double} variables in @code{gcc}.  The
compiler aligns these
@cindex compiler
variables to multiples of 4 bytes, but execution is much faster (on
Pentium and PentiumPro) if @code{double}s are aligned to a multiple of 8
bytes.  By carefully counting the number of variables allocated by the
compiler in performance-critical regions of the code, we have been able
to introduce dummy allocations (using @code{alloca}) that align the
stack properly.  The hack depends crucially on the compiler flags that
are used.  For example, it won't work without
@code{-fomit-frame-pointer}.

In principle, these hacks are no longer required under @code{gcc}
versions 2.95 and later, which automatically align the stack correctly
(see @code{-mpreferred-stack-boundary} in the @code{gcc} manual).
However, we have encountered a
@uref{http://egcs.cygnus.com/ml/gcc-bugs/1999-11/msg00259.html,bug} in
the stack alignment of versions 2.95.[012] that causes FFTW's stack to
be misaligned under some circumstances.  The @code{configure} script
automatically detects this bug and disables @code{gcc}'s stack alignment
in favor of our own hacks when @code{--enable-i386-hacks} is used.

The @code{fftw_test} program outputs speed measurements that you can use
to see if these hacks are beneficial.
@pindex fftw_test
@cindex benchmark

The @code{configure} option @code{--enable-pentium-timer} enables the
use of the Pentium and PentiumPro cycle counter for timing purposes.  In
order to get correct results, you must define @code{FFTW_CYCLES_PER_SEC}
in @code{fftw/config.h} to be the clock speed of your processor; the
resulting FFTW library will be nonportable.  The use of this option is
deprecated.  On serious operating systems (such as Linux), FFTW uses
@code{gettimeofday()}, which has enough resolution and is portable.
(Note that Win32 has its own high-resolution timing routines as well.
FFTW contains unsupported code to use these routines.)

@node Customizing the timer, Generating your own code, gcc and Pentium hacks, Installation and Customization
@section Customizing the timer
@cindex timer, customization of

FFTW needs a reasonably-precise clock in order to find the optimal way
to compute a transform.  On Unix systems, @code{configure} looks for
@code{gettimeofday} and other system-specific timers.  If it does not
find any high resolution clock, it defaults to using the @code{clock()}
function, which is very portable, but forces FFTW to run for a long time
in order to get reliable measurements.
@ffindex gettimeofday
@ffindex clock

If your machine supports a high-resolution clock not recognized by FFTW,
it is therefore advisable to use it.  You must edit
@code{fftw/fftw-int.h}.  There are a few macros you must redefine.  The
code is documented and should be self-explanatory.  (By the way,
@code{fftw-int} stands for @code{fftw-internal}, but for some
inexplicable reason people are still using primitive systems with 8.3
filenames.)

Even if you don't install high-resolution timing code, we still
recommend that you look at the @code{FFTW_TIME_MIN} constant in
@ctindex FFTW_TIME_MIN
@code{fftw/fftw-int.h}. This constant holds the minimum time interval (in
seconds) required to get accurate timing measurements, and should be (at
least) several hundred times the resolution of your clock.  The default
constants are on the conservative side, and may cause FFTW to take
longer than necessary when you create a plan. Set @code{FFTW_TIME_MIN}
to whatever is appropriate on your system (be sure to set the
@emph{right} @code{FFTW_TIME_MIN}@dots{}there are several definitions in
@code{fftw-int.h}, corresponding to different platforms and timers).

As an aid in checking the resolution of your clock, you can use the
@code{tests/fftw_test} program with the @code{-t} option
(c.f. @code{tests/README}). Remember, the mere fact that your clock
reports times in, say, picoseconds, does not mean that it is actually
@emph{accurate} to that resolution.

@node Generating your own code,  , Customizing the timer, Installation and Customization
@section Generating your own code
@cindex Caml
@cindex ML
@cindex code generator

If you know that you will only use transforms of a certain size (say,
powers of @math{2}) and want to reduce the size of the library, you can
reconfigure FFTW to support only those sizes you are interested in.  You
may even generate code to enable efficient transforms of a size not
supported by the default distribution.  The default distribution
supports transforms of any size, but not all sizes are equally fast.
The default installation of FFTW is best at handling sizes of the form
@ifinfo
@math{2^a 3^b 5^c 7^d 11^e 13^f},
@end ifinfo
@tex
$2^a 3^b 5^c 7^d 11^e 13^f$,
@end tex
@ifhtml
2<SUP>a</SUP> 3<SUP>b</SUP> 5<SUP>c</SUP> 7<SUP>d</SUP>
        11<SUP>e</SUP> 13<SUP>f</SUP>,
@end ifhtml
where @math{e+f} is either @math{0} or
@math{1}, and the other exponents are arbitrary.  Other sizes are
computed by means of a slow, general-purpose routine.  However, if you
have an application that requires fast transforms of size, say,
@code{17}, there is a way to generate specialized code to handle that.

The directory @code{gensrc} contains all the programs and scripts that
were used to generate FFTW.  In particular, the program
@code{gensrc/genfft.ml} was used to generate the code that FFTW uses to
compute the transforms.  We do not expect casual users to use it.
@code{genfft} is a rather sophisticated program that generates directed
acyclic graphs of FFT algorithms and performs algebraic simplifications
on them.  @code{genfft} is written in Objective Caml, a dialect of ML.
Objective Caml is described at @uref{http://pauillac.inria.fr/ocaml/}
and can be downloaded from from @uref{ftp://ftp.inria.fr/lang/caml-light}.
@pindex genfft
@cindex Caml

If you have Objective Caml installed, you can type @code{sh
bootstrap.sh} in the top-level directory to re-generate the files.  If
you change the @code{gensrc/config} file, you can optimize FFTW for
sizes that are not currently supported efficiently (say, 17 or 19).

We do not provide more details about the code-generation process, since
we do not expect that users will need to generate their own code.
However, feel free to contact us at @email{fftw@@fftw.org} if
you are interested in the subject.  

@cindex monadic programming
You might find it interesting to learn Caml and/or some modern
programming techniques that we used in the generator (including monadic
programming), especially if you heard the rumor that Java and
object-oriented programming are the latest advancement in the field.
The internal operation of the codelet generator is described in the
paper, ``A Fast Fourier Transform Compiler,'' by M. Frigo, which is
available from the @uref{http://www.fftw.org,FFTW home page}
and will appear in the @cite{Proceedings of the 1999 ACM SIGPLAN
Conference on Programming Language Design and Implementation (PLDI)}.

@c ************************************************************
@node Acknowledgments, License and Copyright, Installation and Customization, Top
@chapter Acknowledgments

Matteo Frigo was supported in part by the Defense Advanced Research
Projects Agency (DARPA) under Grants N00014-94-1-0985 and
F30602-97-1-0270, and by a Digital Equipment Corporation Fellowship.
Steven G. Johnson was supported in part by a DoD NDSEG Fellowship, an
MIT Karl Taylor Compton Fellowship, and by the Materials Research
Science and Engineering Center program of the National Science
Foundation under award DMR-9400334.

Both authors were also supported in part by their respective
girlfriends, by the letters ``Q'' and ``R'', and by the number 12.
@cindex girlfriends

We are grateful to SUN Microsystems Inc.@ for its donation of a cluster
of 9 8-processor Ultra HPC 5000 SMPs (24 Gflops peak). These machines
served as the primary platform for the development of earlier versions
of FFTW.

We thank Intel Corporation for donating a four-processor Pentium Pro
machine.  We thank the Linux community for giving us a decent OS to run
on that machine.

The @code{genfft} program was written using Objective Caml, a dialect of
ML.  Objective Caml is a small and elegant language developed by Xavier
Leroy.  The implementation is available from @code{ftp.inria.fr} in the
directory @code{lang/caml-light}.  We used versions 1.07 and 2.00 of the
software.  In previous releases of FFTW, @code{genfft} was written in
Caml Light, by the same authors.  An even earlier implementation of
@code{genfft} was written in Scheme, but Caml is definitely better for
this kind of application.
@pindex genfft
@cindex Caml
@cindex LISP

FFTW uses many tools from the GNU project, including @code{automake},
@code{texinfo}, and @code{libtool}.

Prof.@ Charles E.@ Leiserson of MIT provided continuous support and
encouragement.  This program would not exist without him.  Charles also
proposed the name ``codelets'' for the basic FFT blocks.

Prof.@ John D.@ Joannopoulos of MIT demonstrated continuing tolerance of
Steven's ``extra-curricular'' computer-science activities.  Steven's
chances at a physics degree would not exist without him.

Andrew Sterian contributed the Windows timing code.  

Didier Miras reported a bug in the test procedure used in FFTW 1.2.  We
now use a completely different test algorithm by Funda Ergun that does
not require a separate FFT program to compare against.

Wolfgang Reimer contributed the Pentium cycle counter and a few fixes
that help portability.

Ming-Chang Liu uncovered a well-hidden bug in the complex transforms of
FFTW 2.0 and supplied a patch to correct it.

The FFTW FAQ was written in @code{bfnn} (Bizarre Format With No Name)
and formatted using the tools developed by Ian Jackson for the Linux
FAQ.

@emph{We are especially thankful to all of our users for their
continuing support, feedback, and interest during our development of
FFTW.}

@c ************************************************************
@node License and Copyright, Concept Index, Acknowledgments, Top
@chapter License and Copyright

FFTW is copyright @copyright{} 1997--1999 Massachusetts Institute of
Technology.

FFTW is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.  You can also
find the @uref{http://www.gnu.org/copyleft/gpl.html, GPL on the GNU web
site}.

In addition, we kindly ask you to acknowledge FFTW and its authors in
any program or publication in which you use FFTW.  (You are not
@emph{required} to do so; it is up to your common sense to decide
whether you want to comply with this request or not.)

Non-free versions of FFTW are available under terms different than the
General Public License. (e.g. they do not require you to accompany any
object code using FFTW with the corresponding source code.)  For these
alternate terms you must purchase a license from MIT's Technology
Licensing Office.  Users interested in such a license should contact us
(@email{fftw@@fftw.org}) for more information.

@node Concept Index, Library Index, License and Copyright, Top
@chapter Concept Index
@printindex cp

@node Library Index,  , Concept Index, Top
@chapter Library Index
@printindex fn

@c ************************************************************
@contents

@bye
@c  LocalWords:  texinfo fftw texi Exp setfilename settitle setchapternewpage
@c  LocalWords:  syncodeindex fn cp vr pg tp ifinfo titlepage sp Matteo Frigo
@c  LocalWords:  vskip pt filll dir detailmenu halfcomplex DFT fftwnd rfftw gcc
@c  LocalWords:  rfftwnd Pentium PentiumPro NJ FFT cindex ESSL FFTW's emph uref
@c  LocalWords:  http lcs mit edu benchfft benchFFT pindex dfn iftex tex cdot
@c  LocalWords:  ifhtml nbsp TR Sep Proc ICASSP Tukey Rader's ref xref int FFTs
@c  LocalWords:  findex tindex vindex im strided pxref DC lfftw lm samp const
@c  LocalWords:  nx ny nz ldots rk ik hc freq lrfftw datatypes cdots pointwise
@c  LocalWords:  pinv ij rote increaseth Ecclesiastes nerd stdout fopen printf
@c  LocalWords:  fclose dimension's malloc sizeof comp lang www eskimo com scs
@c  LocalWords:  faq html README Cilk SMP cilk POSIX Solaris BeOS MacOS mpi mcs
@c  LocalWords:  anl gov mutex THREADSAFE struct leq conj lt hbox istride lg rt
@c  LocalWords:  ostride subsubheading howmany idist odist exp IMG SRC gif IFFT
@c  LocalWords:  frftw dist datatype datatype's nc noindent callback putc getc
@c  LocalWords:  EOF Pentia PentiumPro's codelets CFLAGS cc Omax config org toc
@c  LocalWords:  pentium preconfigured egcs alloca fomit SEC gettimeofday MIN
@c  LocalWords:  picoseconds Caml gensrc genfft pauillac inria fr ocaml ftp sh
@c  LocalWords:  caml DoD NDSEG DMR HPC SMPs Gflops automake libtool Leiserson
@c  LocalWords:  Sterian Didier Miras Funda Ergun Reimer bfnn copyleft gpl
@c  LocalWords:  printindex LocalWords
